.decl Opcode(method: symbol, index: number, opcode: symbol, oper1: symbol, oper2: symbol)
.decl Var(method: symbol, index: symbol, var: symbol)
.input Opcode
.input Var


.type Stack = [top: symbol, rest: Stack]

.decl StackBeforeIndex(method: symbol, index: number, stack: Stack)

.decl UnaryConsumer(opcode: symbol)
.decl BinaryConsumer(opcode: symbol, op: symbol)
.decl VarLoad(opcode: symbol)
.decl VarStore(opcode: symbol)

.decl Instruction(method: symbol, index: number, cmd: symbol)
.output Instruction
.decl RequestVar(method: symbol, index: number, stack: Stack)
.decl RespondVar(method: symbol, index: number, var: symbol)
.decl RequestBINOP_afterInstr(method: symbol, index: number, oper1: symbol, op: symbol, oper2: symbol)

BinaryConsumer("dmul", "*").

VarLoad("aload").
VarLoad("dload").
VarStore("dstore").

StackBeforeIndex(method, 0, [".", nil]) :- Opcode(method, _, _, _, _).

// Push var into stack
StackBeforeIndex(method, i+1, [var, stack]) :-
	StackBeforeIndex(method, i, stack),
	Opcode(method, i, opcode, oper1, _),
	VarLoad(opcode),
	Var(method, oper1, var).

// Compute intermediate result
// Swap order of operands due to stack semantics
RequestBINOP_afterInstr(method, i, oper2, op, oper1),
RequestVar(method, i, stack) :-
	StackBeforeIndex(method, i, [oper1, [oper2, stack]]),
	Opcode(method, i, opcode, _, _),
	BinaryConsumer(opcode, op).

RespondVar(method, i, var) :-
	RequestVar(method, i, stack),
	Opcode(method, i+1, opcode, oper1, _),
	VarStore(opcode),
	Var(method, oper1, var).

RespondVar(method, i, var) :-
	RequestVar(method, i, stack),
	Opcode(method, i+1, opcode, _, _),
	!VarStore(opcode),
	var = cat("$var", to_string(i)).

Instruction(method, i, cat(var, cat(oper1, oper2))),
StackBeforeIndex(method, i+1, [var, stack]) :-
	RequestVar(method, i, stack),
	RespondVar(method, i, var),
	RequestBINOP_afterInstr(method, i, oper1, op, oper2).

Instruction(method, i+2, cat(var, cat("=",cat(oper1, cat(op, oper2))))),
StackBeforeIndex(method, i+2, stack) :-
	RequestVar(method, i, stack),
	RespondVar(method, -1*i, var),
	RequestBINOP_afterInstr(method, i, oper1, op, oper2).







StackBeforeIndex(method, i+1, [oper1, stack]) :-
	StackBeforeIndex(method, i, stack),
	Opcode(method, i, "ldc", oper1, _).

StackBeforeIndex(method, i+1, [oper1, stack]) :-
	StackBeforeIndex(method, i, stack),
	Opcode(method, i, "getstatic", oper1, _).

Instruction(method, i, cat("call", cat(oper1, cat(head1, head2)))),
StackBeforeIndex(method, i+1, stack) :-
	StackBeforeIndex(method, i, [head1, [head2, stack]]),
	Opcode(method, i, "invokevirtual", oper1, _).

StackBeforeIndex(method, i+1, [oper1, stack]) :-
	StackBeforeIndex(method, i, stack),
	Opcode(method, i, "bipush", oper1, _).

Instruction(method, i, cat("return ", head)),
StackBeforeIndex(method, i+1, stack) :-
	StackBeforeIndex(method, i, [head, stack]),
	Opcode(method, i, "ireturn", _, _).

StackBeforeIndex(method, i+1, stack) :-
	StackBeforeIndex(method, i, stack),
	Opcode(method, i, "pop2", _, _).
