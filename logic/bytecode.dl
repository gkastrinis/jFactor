#pragma once
#include "schema.dl"

.type Stack = [top: symbol, rest: Stack]
.decl StackBeforeStmt(stmt: symbol, stack: Stack)

// Annotate operands on the stack with type information
#define TOP(type, oper, stack) [type, [oper, stack]]

.decl TempVar(var: symbol, name: symbol)
.decl TypeToDesc(type: symbol, desc: symbol)
// Opcodes
.decl BinOpcode(opcode: symbol, op: symbol)
.decl UnaryOpcode(opcode: symbol, op: symbol)
.decl ConstLoadOpcode(opcode: symbol, type: symbol)
.decl CallOpcode(opcode: symbol)
.decl ImplicitCondJumpOpcode(opcode: symbol, op: symbol, type1: symbol, oper1: symbol)
.decl CondJumpOpcode(opcode: symbol, op: symbol)

.decl __REQ_StackForNext(stmt: symbol, stack: Stack)
.decl __REQ_Var(stmt: symbol, type: symbol, stack: Stack)
.decl __RES_Var(stmt: symbol, var: symbol)
.decl __REQ_ActualParam(stmt: symbol, pos: number, stack: Stack)
.decl __REQ_Assign(stmt: symbol, to: symbol)
.decl __REQ_Operand(stmt: symbol, pos: number, type: symbol, value: symbol)

#define T2DESC(type, desc) \
(TypeToDesc(type, desc) ; (!TypeToDesc(type, _), desc = type))

#define DESC2T(type, desc) \
(TypeToDesc(type, desc) ; (!TypeToDesc(_, desc), type = desc))

///////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////

// -> constant value
__REQ_StackForNext(stmt, TOP(tDesc, const, stack)) :-
	StackBeforeStmt(stmt, stack),
	OpcodeExt(stmt, opcode, const),
	ConstLoadOpcode(opcode, type), T2DESC(type, tDesc).

// -> value
__REQ_StackForNext(stmt, TOP(tDesc, var, stack)) :-
	StackBeforeStmt(stmt, stack),
	OpcodeExt(stmt, "X-load", var),
	p1_Var(_, var, type, _), T2DESC(type, tDesc).

// value ->
__REQ_Assign(stmt, var),
__REQ_Operand(stmt, 0, type, oper),
__REQ_StackForNext(stmt, stack) :-
	StackBeforeStmt(stmt, TOP(type, oper, stack)),
	OpcodeExt(stmt, "X-store", var).
// TODO compare types
//	VAR(_, var, type, _).

// return value ->
p1_Ret(stmt),
p1_Operand(stmt, 0, type, oper),
__REQ_StackForNext(stmt, stack) :-
	StackBeforeStmt(stmt, TOP(type, oper, stack)),
	OpcodeExt(stmt, "X-return", _).

// return void
p1_RetVoid(stmt),
__REQ_StackForNext(stmt, stack) :-
	StackBeforeStmt(stmt, stack),
	OpcodeExt(stmt, "return", _).

// Compute an intermediate result
// Swap order of operands due to stack semantics
p1_Operator(stmt, op),
__REQ_Operand(stmt, 0, type0, oper0),
__REQ_Operand(stmt, 1, type1, oper1),
__REQ_Var(stmt, type, stack) :-
	StackBeforeStmt(stmt, TOP(type1, oper1, TOP(type0, oper0, stack))),
	OpcodeExt(stmt, opcode, _),
	BinOpcode(opcode, op),
	type = ";I". // todo infer type based on type1 and type0

p1_Operator(stmt, op),
__REQ_Operand(stmt, 0, type0, oper0),
__REQ_Var(stmt, type, stack) :-
	StackBeforeStmt(stmt, TOP(type0, oper0, stack)),
	OpcodeExt(stmt, opcode, _),
	UnaryOpcode(opcode, op),
	type = ";I". // todo infer type based on type1

// Handle ++, --, +=, -=
p1_Assign(stmt, var),
p1_Operator(stmt, op),
p1_Operand(stmt, 0, tDesc0, var),
p1_Operand(stmt, 1, tDesc1, value),
__REQ_StackForNext(stmt, stack) :-
	StackBeforeStmt(stmt, stack),
	((OpcodeExt(stmt, "X-inc", var), op = "+") ;
	 (OpcodeExt(stmt, "X-dec", var), op = "-")),
	p1_Var(_, var, type0, _), T2DESC(type0, tDesc0),
	IncValue(stmt, value, type1), T2DESC(type1, tDesc1).

// Handle conditional jumps
p1_If(stmt, nextStmt),
p1_Operator(stmt, op),
p1_Operand(stmt, 0, type0, oper0),
p1_Operand(stmt, 1, type1, oper1),
__REQ_StackForNext(stmt, stack) :-
	StackBeforeStmt(stmt, TOP(type0, oper0, stack)),
	OpcodeExt(stmt, opcode, nextStmt),
	ImplicitCondJumpOpcode(opcode, op, type1, oper1).

p1_If(stmt, nextStmt),
p1_Operator(stmt, op),
p1_Operand(stmt, 0, type0, oper0),
p1_Operand(stmt, 1, type1, oper1),
__REQ_StackForNext(stmt, stack) :-
	StackBeforeStmt(stmt, TOP(type1, oper1, TOP(type0, oper0, stack))),
	OpcodeExt(stmt, opcode, nextStmt),
	CondJumpOpcode(opcode, op).

// ... and unconditional ones
p1_Goto(stmt, nextStmt),
__REQ_StackForNext(stmt, stack) :-
	StackBeforeStmt(stmt, stack),
	OpcodeExt(stmt, "goto", nextStmt).

// Store the top of the stack into a var
// Found in source code
__RES_Var(stmt, var) :-
	__REQ_Var(stmt, _, _), // TODO type check
	p1_Next(stmt, nextStmt),
	OpcodeExt(nextStmt, "X-store", var).

// ...or generate a temp one
TempVar(var, varName),
p1_Var(method, var, type, varName),
__RES_Var(stmt, var) :-
	__REQ_Var(stmt, tDesc, _),
	BytecodeStmt(stmt, method, i),
	p1_Next(stmt, nextStmt),
	OpcodeExt(nextStmt, opcode, _),
	opcode != "X-store",
	varName = cat("$r", to_string(i)),
	var = cat(cat(method, "/"), varName),
	DESC2T(type, tDesc).

// Handle all assignments to temp or source code vars
__REQ_Assign(stmt, var),
__REQ_StackForNext(stmt, TOP(type, var, stack)) :-
	__REQ_Var(stmt, type, stack),
	__RES_Var(stmt, var).

// Fields... ///////////////////////////////////////////////////

// Load static field
p1_Sload(stmt, fld),
__REQ_Var(stmt, tDesc, stack) :-
	StackBeforeStmt(stmt, stack),
	OpcodeExt(stmt, "getstatic", fld),
	Field(fld, type, _, _), T2DESC(type, tDesc).

///////////////////////////////////////////////////////////////

// -> heap id
__REQ_StackForNext(stmt, TOP(type, heap, stack)) :-
	StackBeforeStmt(stmt, stack),
	OpcodeExt(stmt, "new", heap),
	AllocType(stmt, type).

// Dup should only follow a `new` opcode -- ignore it
__REQ_StackForNext(stmt, stack) :-
	StackBeforeStmt(stmt, stack),
	OpcodeExt(stmt, "dup", _).

ERROR(stmt, "dup should follow only a `new` opcode") :-
	OpcodeExt(stmt, "dup", _),
	p1_Next(prev, stmt),
	!OpcodeExt(prev, "new", _).

__REQ_StackForNext(stmt, stack) :-
	StackBeforeStmt(stmt, [_, stack]),
	OpcodeExt(stmt, "pop", _).

// Calls... ///////////////////////////////////////////////////

// Pop call arguments from stack
__REQ_ActualParam(stmt, argc - 1, stack) :-
	StackBeforeStmt(stmt, stack),
	OpcodeExt(stmt, opcode, sig),
	CallOpcode(opcode),
	Invocation(sig, argc, _, _).

// index -1 should keep either the receiver object or a heap id
// index -2 should keep the stack without anything related to the call

// actual arg1, arg2, ... ->
__REQ_ActualParam(stmt, pos - 1, stack) :-
	__REQ_ActualParam(stmt, pos, TOP(_, _, stack)), pos >= 0.

// receiver var, or heap allocation ->
__REQ_ActualParam(stmt, -2, stack) :-
	__REQ_ActualParam(stmt, -1, TOP(_, _, stack)),
	OpcodeExt(stmt, opcode, _),
	opcode != "invokestatic".

// duplicate stack for index -2 for static calls
__REQ_ActualParam(stmt, -2, stack) :-
	__REQ_ActualParam(stmt, -1, stack),
	OpcodeExt(stmt, "invokestatic", _).

p1_Operand(stmt, pos, type, notHeap) :-
	__REQ_ActualParam(stmt, pos, TOP(tDesc, notHeap, _)), pos >= 0,
	!p1_Alloc(_, _, notHeap, _),
	DESC2T(type, tDesc).

// Use the var instead of the heap id, as argument
p1_Operand(stmt, pos, type, var) :-
	__REQ_ActualParam(stmt, pos, TOP(tDesc, heap, _)), pos >= 0,
	p1_Alloc(_, var, heap, _),
	DESC2T(type, tDesc).

// Pop receiver object from stack
p1_VCall(stmt, base, sig) :-
	OpcodeExt(stmt, "invokevirtual", sig),
	__REQ_ActualParam(stmt, -1, TOP(_, base, _)).

// Pop receiver object from stack
p1_Assign(allocStmt, base),
p1_Alloc(allocStmt, base, heap, type),
p1_SPCall(stmt, base, sig) :-
	OpcodeExt(stmt, "X-invokeinit", sig),
	__REQ_ActualParam(stmt, -1, TOP(type, heap, _)),
	OpcodeExt(allocStmt, "new", heap),
	__RES_Var(stmt, base).

// Pop receiver object from stack
p1_SPCall(stmt, base, sig) :-
	OpcodeExt(stmt, "invokespecial", sig),
	__REQ_ActualParam(stmt, -1, TOP(_, base, _)).

p1_SCall(stmt, sig) :- OpcodeExt(stmt, "invokestatic", sig).

// -> var to store invocation result
__REQ_Var(stmt, retDesc, stack) :-
	OpcodeExt(stmt, opcode, sig),
	CallOpcode(opcode),
	Invocation(sig, _, retType, _),
	(retType != "void" ; opcode = "X-invokeinit"),
	T2DESC(retType, retDesc),
	__REQ_ActualParam(stmt, -2, stack).

// Propagate stack on void-returning calls (that are not constructors)
__REQ_StackForNext(stmt, stack) :-
	OpcodeExt(stmt, opcode, sig),
	CallOpcode(opcode),
	Invocation(sig, _, "void", _), opcode != "X-invokeinit",
	__REQ_ActualParam(stmt, -2, stack).

///////////////////////////////////////////////////////////////

p1_Throw(stmt, var),
__REQ_StackForNext(stmt, stack) :-
	StackBeforeStmt(stmt, TOP(_, var, stack)),
	OpcodeExt(stmt, "athrow", _).

// Initialize stack for first statement
StackBeforeStmt(stmt, nil) :- BytecodeStmt(stmt, _, 0).

// Propagate stack to all successors
StackBeforeStmt(nextStmt, stack) :-
	__REQ_StackForNext(stmt, stack),
	p1_Next(stmt, nextStmt).

// Prepare stack for an exception handler
StackBeforeStmt(handlerStmt, TOP(type, type, nil)) :-
	p1_ExceptionHandler(_, _, _, handlerStmt, type, _).

///////////////////////////////////////////////////////////////

// Approve all assignments, except self-assign ones
p1_Assign(stmt, to) :-
	__REQ_Assign(stmt, to),
	!__REQ_Operand(stmt, 0, _, to).

p1_Assign(stmt, to) :-
	__REQ_Assign(stmt, to),
	__REQ_Operand(stmt, 0, _, to),
	__REQ_Operand(stmt, 1, _, _).

p1_Operand(stmt, pos, type, oper) :-
	__REQ_Operand(stmt, pos, type, oper),
	p1_Assign(stmt, _).

// Treat assigned return values as operands in pos -1
p1_Operand(stmt, -1, type, var) :-
	__REQ_Assign(stmt, var),
	p1_Var(_, var, type, _),
	OpcodeExt(stmt, opcode, _),
	CallOpcode(opcode).

///////////////////////////////////////////////////////////////
// Setup...
///////////////////////////////////////////////////////////////

TypeToDesc("byte", ";B").
TypeToDesc("char", ";C").
TypeToDesc("double", ";D").
TypeToDesc("float", ";F").
TypeToDesc("int", ";I").
TypeToDesc("long", ";J").
TypeToDesc("short", ";S").
TypeToDesc("void", ";V").

ConstLoadOpcode("X-Bconst", ";B").
ConstLoadOpcode("X-Cconst", ";C").
ConstLoadOpcode("X-Dconst", ";D").
ConstLoadOpcode("X-Fconst", ";F").
ConstLoadOpcode("X-Iconst", ";I").
ConstLoadOpcode("X-Jconst", ";J").
ConstLoadOpcode("X-Sconst", ";S").
ConstLoadOpcode("X-Lconst", ";L"). // string literals or NULL

BinOpcode("X-add", "+").
BinOpcode("X-sub", "-").
BinOpcode("X-mul", "*").
BinOpcode("X-div", "/").
BinOpcode("X-rem", "%").
BinOpcode("X-band", "&").
BinOpcode("X-bor", "|").
BinOpcode("X-bxor", "^").
BinOpcode("X-shl", "<<").
BinOpcode("X-shr", ">>").
BinOpcode("X-ushr", ">>>").
BinOpcode("lcmp", "cmp").
BinOpcode("cmpl", "cmp").
BinOpcode("cmpg", "cmp").
UnaryOpcode("X-neg", "-").

CallOpcode("invokevirtual").
CallOpcode("invokespecial").
CallOpcode("X-invokeinit").
CallOpcode("invokestatic").

ImplicitCondJumpOpcode("ifeq", "==", ";B", "0").
ImplicitCondJumpOpcode("ifne", "!=", ";B", "0").
ImplicitCondJumpOpcode("iflt", "<", ";B", "0").
ImplicitCondJumpOpcode("ifge", ">=", ";B", "0").
ImplicitCondJumpOpcode("ifgt", ">", ";B", "0").
ImplicitCondJumpOpcode("ifle", "<=", ";B", "0").
ImplicitCondJumpOpcode("ifnull", "==", ";L", "NULL").
ImplicitCondJumpOpcode("ifnonnull", "!=", ";L", "NULL").

CondJumpOpcode("if_icmpeq", "==").
CondJumpOpcode("if_icmpne", "!=").
CondJumpOpcode("if_icmplt", "<").
CondJumpOpcode("if_icmpge", ">=").
CondJumpOpcode("if_icmpgt", ">").
CondJumpOpcode("if_icmple", "<=").
CondJumpOpcode("if_acmpeq", "==").
CondJumpOpcode("if_acmpne", "!=").

///////////////////////////////////////////////////////////////

// The endIndex in VarRange is not inclusive in the original bytecode
p1_Var(method, var, type, name),
p1_VarRange(var, startIndex, endIndex - 1) :-
	p0_Var(method, _, var, name, type, startLabel, endLabel),
	Label(method, startLabel, _, startIndex),
	Label(method, endLabel, _, endIndex).

// Match load/store statements to variable scopes
// The first store statement of a variable is located
// one index before the variable's scope start
OpcodeExt(stmt, opcode, var) :-
	((p0_Opcode(stmt, "X-load", varIndex), opcode = "X-load");
	 (p0_Opcode(stmt, "X-store", varIndex), opcode = "X-store");
	 (p0_Opcode(stmt, "X-inc", varIndex), opcode = "X-inc");
	 (p0_Opcode(stmt, "X-dec", varIndex), opcode = "X-dec")),
	BytecodeStmt(stmt, method, index),
	p0_Var(method, varIndex, var, _, _, _, _),
	p1_VarRange(var, startIndex, endIndex),
	(startIndex - 1) <= index, index <= endIndex.

// Exception handlers might introduce unnamed variables
TempVar(var, varName),
p1_Var(method, var, "java.lang.Throwable", varName),
OpcodeExt(stmt, opcode, var) :-
	((p0_Opcode(stmt, "X-load", varIndex), opcode = "X-load");
	 (p0_Opcode(stmt, "X-store", varIndex), opcode = "X-store")),
	BytecodeStmt(stmt, method, _),
	!p0_Var(method, varIndex, _, _, _, _, _),
	varName = cat("$throw", varIndex),
	var = cat(cat(method, "/"), varName).

// Anything other than var load/store and jumps
OpcodeExt(stmt, opcode, oper) :-
	p0_Opcode(stmt, opcode, oper),
	opcode != "X-load",
	opcode != "X-store",
	opcode != "X-inc",
	opcode != "X-dec",
	opcode != "goto",
	!ImplicitCondJumpOpcode(opcode, _, _, _),
	!CondJumpOpcode(opcode, _).

p1_Next(stmt, nextStmt),
OpcodeExt(stmt, opcode, nextStmt) :-
	p0_Opcode(stmt, opcode, label),
	(ImplicitCondJumpOpcode(opcode, _, _, _) ;
	 CondJumpOpcode(opcode, _)),
	BytecodeStmt(stmt, method, _),
	Label(method, label, nextStmt, _).

p1_Next(stmt, nextStmt),
OpcodeExt(stmt, "goto", nextStmt) :-
	p0_Opcode(stmt, "goto", label),
	BytecodeStmt(stmt, method, _),
	Label(method, label, nextStmt, _).

// The next statement, in sequence, is also a successor in most cases
p1_Next(stmt, cat(method, cat("/", to_string(i + 1)))) :-
	p0_Opcode(stmt, opcode, _),
	BytecodeStmt(stmt, method, i),
	opcode != "goto",
	opcode != "athrow",
	opcode != "X-return",
	opcode != "return".

// Assume that the first instruction of a handler is a store
p1_ExceptionHandler(method, startStmt, endStmt, handlerStmt, type, var) :-
	Handler(method, startLabel, endLabel, handlerLabel, type),
	Label(method, startLabel, startStmt, _),
	Label(method, endLabel, endStmt, _),
	Label(method, handlerLabel, handlerStmt, _),
	OpcodeExt(handlerStmt, "X-store", var).

ERROR(handlerStmt, "first stmt of handler should be a `store` opcode") :-
	Handler(method, _, _, handlerLabel, _),
	Label(method, handlerLabel, handlerStmt, _),
	OpcodeExt(handlerStmt, opcode, _),
	opcode != "X-store".

ERROR(stmt, cat("stmt is not associated with a stack for: ", opcode)) :-
	OpcodeExt(stmt, opcode, _),
	!StackBeforeStmt(stmt, _).