#pragma once
#include "schema.dl"
#include "basic-blocks.dl"
#include "ssa.dl"

// Order vars participating in PHI nodes, for a given basic block
.decl VarToOrdInPHI(inBB: symbol, var: symbol, order: number)
.decl SSAVarToOrdInPHI(inBB: symbol, var: symbol, ssaVar: symbol, order: number)
.decl NextBaseVarInPHI(inBB: symbol, prev: symbol, next: symbol)
.decl NextSSAVarForVarInPHI(inBB: symbol, var: symbol, prev: symbol, next: symbol)
.decl NextVarInPHI(index: number, inBB: symbol, prev: symbol, next: symbol)
.decl TotalSSAVarsInPHI(inBB: symbol, total: number)

#define NIL "@"

// Arbitrarily order vars, and ssa-variants of the same var
VarToOrdInPHI(inBB, var, ord(var)),
SSAVarToOrdInPHI(inBB, var, ssaVar, ord(ssaVar)) :-
	SSA_PHI(inBB, var),
	VarAliveAtStartOfBB(var, ssaVar, inBB).

// Order base vars
NextBaseVarInPHI(inBB, NIL, var) :-
	VarToOrdInPHI(inBB, var, minOrd),
	minOrd = min ord1 : { VarToOrdInPHI(inBB, _, ord1) }.

NextBaseVarInPHI(inBB, prevVar, nextVar) :-
	NextBaseVarInPHI(inBB, _, prevVar),
	VarToOrdInPHI(inBB, prevVar, prevOrd),
	VarToOrdInPHI(inBB, nextVar, nextOrd),
	nextOrd = min ord1 : { VarToOrdInPHI(inBB, _, ord1), ord1 > prevOrd }.

// Order ssa-variants, for a given base var
NextSSAVarForVarInPHI(inBB, var, NIL, minSsaVar) :-
	SSAVarToOrdInPHI(inBB, var, minSsaVar, minOrd),
	minOrd = min ord1 : { SSAVarToOrdInPHI(inBB, var, _, ord1) }.

NextSSAVarForVarInPHI(inBB, var, prevVar, nextVar) :-
	NextSSAVarForVarInPHI(inBB, var, _, prevVar),
	SSAVarToOrdInPHI(inBB, var, prevVar, prevOrd),
	SSAVarToOrdInPHI(inBB, var, nextVar, nextOrd),
	nextOrd = min ord1 : { SSAVarToOrdInPHI(inBB, var, _, ord1), ord1 > prevOrd }.

// First ssa-variant, of the first var in the basic block
NextVarInPHI(0, inBB, NIL, minSsaVar) :-
	NextBaseVarInPHI(inBB, NIL, var),
	NextSSAVarForVarInPHI(inBB, var, NIL, minSsaVar).

// Next ssa-variant, based on the previous ssa-variant
NextVarInPHI(prevIndex + 1, inBB, prevVar, nextVar) :-
	NextVarInPHI(prevIndex, inBB, _, prevVar),
	NextSSAVarForVarInPHI(inBB, _, prevVar, nextVar).

// Previous ssa-variant has no next variant
// Move on to the first ssa-variant of the next base var
NextVarInPHI(prevIndex + 1, inBB, prevVar, nextVar) :-
	NextVarInPHI(prevIndex, inBB, _, prevVar),
	!NextSSAVarForVarInPHI(inBB, _, prevVar, _),
	SSAVarToOrdInPHI(inBB, baseVar, prevVar, _),
	NextBaseVarInPHI(inBB, baseVar, nextBaseVar),
	NextSSAVarForVarInPHI(inBB, nextBaseVar, NIL, nextVar).

// Total count of variables in current PHI hyper-node
TotalSSAVarsInPHI(inBB, lastIndex + 1) :-
	SSA_PHI(inBB, _),
	NextVarInPHI(lastIndex, inBB, _, lastVar),
	!NextVarInPHI(lastIndex + 1, inBB, lastVar, _).

// Start from -1, to avoid PHI nodes at the beginning of a method
Stmt(PROLOGUE_STMT(method), method, -1, -1) :- BytecodeStmt(_, method, _).

// For non-PHI nodes, just increment the index
Stmt(newStmt, method, bytecodeIndex + 1, prevIndex + 1) :-
	Stmt(_, method, bytecodeIndex, prevIndex),
	BytecodeStmt(stmt, method, bytecodeIndex + 1),
	!SSA_PHI(stmt, _),
	index = prevIndex + 1,
	newStmt = cat(method, cat("/", to_string(index))).

// Calculate the index of the first, non-PHI assignment in a PHI node
Stmt(newStmt, method, bytecodeIndex + 1, index) :-
	Stmt(_, method, bytecodeIndex, prevIndex),
	BytecodeStmt(stmt, method, bytecodeIndex + 1),
	SSA_PHI(stmt, _),
	TotalSSAVarsInPHI(stmt, total),
	index = prevIndex + 1 + total,
	newStmt = cat(method, cat("/", to_string(index))).

// Give each PHI assignment an index based on ordering
// -2 for original bytecode index
Stmt(newStmt, method, -2, index) :-
	Stmt(_, method, bytecodeIndex, prevIndex),
	BytecodeStmt(stmt, method, bytecodeIndex + 1),
	SSA_PHI(stmt, _),
	NextVarInPHI(indexInPHI, stmt, _, _),
	index = prevIndex + 1 + indexInPHI,
	newStmt = cat(method, cat("/", cat(to_string(index), "/PHI"))).