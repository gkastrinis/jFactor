#pragma once

// Terms...
// * BC = Bytecode
// * BB = Basic-Block
// * SSA = Static Single Assignment

// Output //
.decl VAR(method: symbol, var: symbol, type: symbol, name: symbol)
.decl VarRange(var: symbol, startIndex: number, endIndex: number)
.decl SSAVarToOriginal(ssaVar: symbol, var: symbol)
// Stmt with the final ordering
.decl Stmt(stmt: symbol, method: symbol, bytecodeIndex: number, index: number)
.decl NextStmt(fromStmt: symbol, toStmt: symbol)
.decl ASSIGN(stmt: symbol, to: symbol)
.decl Operator(stmt: symbol, op: symbol)
.decl Operand_VAR(stmt: symbol, pos: number, oper: symbol)
.decl Operand_CONST(stmt: symbol, pos: number, oper: symbol, type: symbol)
.decl SLOAD(stmt: symbol, fld: symbol)
.decl RET(stmt: symbol)
.decl RET_VOID(stmt: symbol)
.decl IF(stmt: symbol, jumpStmt: symbol)
.decl GOTO(stmt: symbol, jumpStmt: symbol)
.decl ALLOC(stmt: symbol, to: symbol, heap: symbol, type: symbol)
.decl VCALL(stmt: symbol, base: symbol, sig: symbol)
.decl SPCALL(stmt: symbol,  base: symbol, sig: symbol)
.decl SCALL(stmt: symbol,  sig: symbol)
.decl THROW(stmt: symbol, var: symbol)
.decl EXCEPTION_HANDLER(method: symbol, fromStmt: symbol, toStmt: symbol, handlerStmt: symbol, type: symbol, var: symbol)

// Input //
.decl FORMAL_PARAM(method: symbol, pos: number, var: symbol)

.decl BytecodeStmt(id: symbol, method: symbol, index: number)
.decl Label(method: symbol, label: symbol, stmt: symbol, index: number)
.decl Handler(method: symbol, startLabel: symbol, endLabel: symbol, handlerLabel: symbol, type: symbol)
.decl Invocation(sig: symbol, argc: number, retType: symbol, qualifiedName: symbol)
.decl AllocType(stmt: symbol, type: symbol)
.decl IncValue(stmt: symbol, value : symbol, type: symbol)
.decl Field(fld: symbol, type: symbol, name: symbol, owner: symbol)
.decl p0_Var(method: symbol, varIndex: symbol, var: symbol, name: symbol, type: symbol, startLabel: symbol, endLable: symbol)
.decl p0_Opcode(stmt: symbol, opcode: symbol, oper: symbol)
.input FORMAL_PARAM
.input BytecodeStmt
.input Label
.input Handler
.input Invocation
.input AllocType
.input IncValue
.input Field
.input p0_Var(filename="Var.facts")
.input p0_Opcode(filename="Opcode.facts")

// Core //
.decl ERROR(stmt: symbol, msg: symbol)
.decl OpcodeExt(stmt: symbol, opcode: symbol, oper: symbol)
// Bytecode phase
.decl p1_Var(method: symbol, var: symbol, type: symbol, name: symbol)
.decl p1_VarRange(var: symbol, startIndex: number, endIndex: number)
.decl p1_Next(fromStmt: symbol, toStmt: symbol)
.decl p1_Assign(stmt: symbol, to: symbol)
.decl p1_Operator(stmt: symbol, op: symbol)
.decl p1_Operand(stmt: symbol, pos: number, type: symbol, oper: symbol)
.decl p1_Sload(stmt: symbol, fld: symbol)
.decl p1_Ret(stmt: symbol)
.decl p1_RetVoid(stmt: symbol)
.decl p1_If(stmt: symbol, jumpStmt: symbol)
.decl p1_Goto(stmt: symbol, jumpStmt: symbol)
.decl p1_Alloc(stmt: symbol, to: symbol, heap: symbol, type: symbol)
.decl p1_VCall(stmt: symbol, base: symbol, sig: symbol)
.decl p1_SPCall(stmt: symbol, base: symbol, sig: symbol)
.decl p1_SCall(stmt: symbol, sig: symbol)
.decl p1_Throw(stmt: symbol, var: symbol)
.decl p1_ExceptionHandler(method: symbol, fromStmt: symbol, toStmt: symbol, handlerStmt: symbol, type: symbol, var: symbol)
// SSA phase
.decl p2_Assign(stmt: symbol, var: symbol, ssaVar: symbol, index: number, inBB: symbol)
.decl p2_Operand(stmt: symbol, pos: number, oper: symbol)
