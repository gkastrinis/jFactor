#pragma once

// Output //
.decl VAR(method: symbol, var: symbol, type: symbol, name: symbol)
// Stmt with the final ordering
.decl Stmt(stmt: symbol, method: symbol, bytecodeIndex: number, index: number)

// TODO stmt needs fixing after all the ordering is computed
.decl VCALL(stmt: symbol, base: symbol, sig: symbol)
.decl SPCALL(stmt: symbol,  base: symbol, sig: symbol)
.decl SCALL(stmt: symbol,  sig: symbol)
.decl ALLOC(stmt: symbol, to: symbol, heap: symbol, type: symbol)
.decl IF(stmt: symbol, jumpStmt: symbol)
.decl GOTO(stmt: symbol, jumpStmt: symbol)
.decl RET(stmt: symbol)
.decl RET_VOID(stmt: symbol)
.decl ACTUAL_PARAM(stmt: symbol, pos: number, op: symbol)
.decl ACTUAL_RET(stmt: symbol, var: symbol)
.decl NEXT(fromStmt: symbol, toStmt: symbol)
.decl THROW(stmt: symbol, var: symbol)
.decl EXCEPTION_HANDLER(method: symbol, fromStmt: symbol, toStmt: symbol, handlerStmt: symbol, type: symbol, var: symbol)
.decl SLOAD(stmt: symbol)

// Input //
.decl FORMAL_PARAM(method: symbol, pos: number, var: symbol)

.decl BytecodeStmt(id: symbol, method: symbol, index: number)
.decl Label(method: symbol, label: symbol, stmt: symbol, index: number)
.decl Handler(method: symbol, startLabel: symbol, endLabel: symbol, handlerLabel: symbol, type: symbol)
.decl Invocation(sig: symbol, argc: number, retType: symbol)
.decl AllocType(stmt: symbol, type: symbol)
.decl IncValue(stmt: symbol, value : symbol, type: symbol)
.decl Field(fld: symbol, type: symbol, name: symbol, owner: symbol)
.decl __Var(method: symbol, varIndex: symbol, var: symbol, name: symbol, type: symbol, startLabel: symbol, endLable: symbol)
.decl __Opcode(stmt: symbol, opcode: symbol, oper: symbol)
.input FORMAL_PARAM
.input BytecodeStmt
.input Label
.input Handler
.input Invocation
.input AllocType
.input IncValue
.input Field
.input __Var(filename="Var.facts")
.input __Opcode(filename="Opcode.facts")

// Core //
.decl ERROR(stmt: symbol, msg: symbol)
.decl OpcodeExt(stmt: symbol, opcode: symbol, oper: symbol)
.decl p1_Assign(stmt: symbol, to: symbol)
.decl p1_Operator(stmt: symbol, op: symbol)
.decl p1_Operand(stmt: symbol, pos: number, type: symbol, oper: symbol)

// TODO doesnt reflect new ordering
.decl VarRange(var: symbol, startIndex: number, endIndex: number)