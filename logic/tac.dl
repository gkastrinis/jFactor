#pragma once
#include "ordering.dl"

.decl TAC(method: symbol, index: number, tac: symbol)
.decl TAC_RHS(stmt: symbol, out: symbol)
.decl OperandStr(stmt: symbol, pos: number, out: symbol)
.decl AllOperandsStrDownTo(stmt: symbol, pos: number, out: symbol)
.decl CallStmt(stmt: symbol, sig: symbol)

CallStmt(stmt, sig) :- VCALL(stmt, _, sig) ; SPCALL(stmt, _, sig) ; SCALL(stmt, sig).

// Ignore `pos` == -1, that stores the receiver object of a call
OperandStr(stmt, pos, name) :-
	Operand_VAR(stmt, pos, var), pos >= 0,
	VAR(_, var, _, name, _).

OperandStr(stmt, pos, const) :-
	Operand_CONST(stmt, pos, const, _).

// BINOP
TAC_RHS(stmt, cat(out0, cat(cat(" ", cat(op, " ")), out1))) :-
	Operator(stmt, op),
	OperandStr(stmt, 0, out0),
	OperandStr(stmt, 1, out1).

// UNOP
TAC_RHS(stmt, cat(cat(op, " "), out0)) :-
	Operator(stmt, op),
	OperandStr(stmt, 0, out0),
	!OperandStr(stmt, 1, _).

// Move instructions or var initializations
TAC_RHS(stmt, out) :-
	OperandStr(stmt, 0, out),
	!CallStmt(stmt, _),
	!Operator(stmt, _),
	!OperandStr(stmt, 1, _).

// Call parameters
// Start from the last operand
AllOperandsStrDownTo(stmt, pos - 1, out) :-
	OperandStr(stmt, pos, out),
	!Operator(stmt, _),
	!OperandStr(stmt, pos + 1, _).

AllOperandsStrDownTo(stmt, pos - 1, cat(out1, cat(", ", out))) :-
	AllOperandsStrDownTo(stmt, pos, out),
	OperandStr(stmt, pos, out1).

// Invocations with no arguments
AllOperandsStrDownTo(stmt, -1, "") :-
	CallStmt(stmt, sig),
	Invocation(sig, 0, _, _).

TAC_RHS(stmt, cat(cat(cat(baseName, "."), cat(qualifiedName, "(")), cat(out, ")"))) :-
	(VCALL(stmt, base, sig) ; SPCALL(stmt, base, sig)),
	AllOperandsStrDownTo(stmt, -1, out),
	Invocation(sig, _, _, qualifiedName),
	Stmt(stmt, method, _, _),
	VAR(method, base, _, baseName, _).

TAC_RHS(stmt, cat(cat(qualifiedName, "("), cat(out, ")"))) :-
	SCALL(stmt, sig),
	Invocation(sig, _, _, qualifiedName),
	AllOperandsStrDownTo(stmt, -1, out).

// Allocations
TAC_RHS(stmt, cat("new ", type)) :- ALLOC(stmt, _, _, type).

// Static field load
TAC_RHS(stmt, fld) :- SLOAD(stmt, fld).

// Assignments
TAC(method, index, cat(cat(name, " = "), out)) :-
	(ASSIGN(stmt, to) ; PHI_ASSIGN(stmt, to)),
	!INIT_CALL(stmt),
	Stmt(stmt, method, _, index),
	VAR(method, to, _, name, _),
	TAC_RHS(stmt, out).

// Calls to a constructor
TAC(method, index, out) :-
	SPCALL(stmt, _, _),
	Stmt(stmt, method, _, index),
	INIT_CALL(stmt),
	TAC_RHS(stmt, out).

// Calls without a return value
TAC(method, index, tac) :-
	CallStmt(stmt, _),
	Stmt(stmt, method, _, index),
	!ASSIGN(stmt, _),
	TAC_RHS(stmt, tac).

TAC(method, index, "return") :-
	RET_VOID(stmt),
	Stmt(stmt, method, _, index).

TAC(method, index, cat("return ", out)) :-
	RET(stmt),
	Stmt(stmt, method, _, index),
	OperandStr(stmt, 0, out).

TAC(method, index, cat("goto ", to_string(jumpIndex))) :-
	GOTO(stmt, jumpStmt),
	Stmt(stmt, method, _, index),
	Stmt(jumpStmt, method, _, jumpIndex).

// TODO recognise if block so it can be indented later
TAC(method, index, cat(cat("if (", out), cat(") jump ", to_string(jumpIndex)))) :-
	IF(stmt, jumpStmt),
	Stmt(stmt, method, _, index),
	Stmt(jumpStmt, method, _, jumpIndex),
	TAC_RHS(stmt, out).

// TODO mark handler blocks
TAC(method, index, cat("throw ", varName)) :-
	THROW(stmt, var),
	Stmt(stmt, method, _, index),
	VAR(method, var, _, varName, _).

// TODO fix jump targets to correspond to visible statements
TAC(method, index, "---LABEL---") :-
	(IF(_, jumpStmt) ; GOTO(_, jumpStmt)),
	Stmt(jumpStmt, method, _, index).