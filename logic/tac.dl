#pragma once
#include "ordering.dl"

.decl TAC(method: symbol, index: number, tac: symbol)
.decl TAC_RHS(stmt: symbol, out: symbol)
.decl OperandStr(stmt: symbol, pos: number, out: symbol)
.decl AllOperandsStrDownTo(stmt: symbol, pos: number, out: symbol)

OperandStr(stmt, pos, varName) :-
	Operand_VAR(stmt, pos, var),
	Stmt(stmt, method, _, _),
	VAR(method, var, _, varName, _).

OperandStr(stmt, pos, const) :-
	Operand_CONST(stmt, pos, const, _).

// Put `to` variable in index -3
OperandStr(stmt, -3, name) :-
	ASSIGN(stmt, to),
	Stmt(stmt, method, _, _),
	VAR(method, to, _, name, _).

// BINOP
TAC_RHS(stmt, cat(out0, cat(cat(" ", cat(op, " ")), out1))) :-
	Operator(stmt, op),
	OperandStr(stmt, 0, out0),
	OperandStr(stmt, 1, out1).

// UNOP
TAC_RHS(stmt, cat(cat(op, " "), out0)) :-
	Operator(stmt, op),
	OperandStr(stmt, 0, out0),
	!OperandStr(stmt, 1, _).

// Call parameters
// Start from the last operand
AllOperandsStrDownTo(stmt, pos - 1, out) :-
	OperandStr(stmt, pos, out),
	!Operator(stmt, _),
	!OperandStr(stmt, pos + 1, _).

AllOperandsStrDownTo(stmt, pos - 1, cat(out1, cat(", ", out))) :-
	AllOperandsStrDownTo(stmt, pos, out),
	OperandStr(stmt, pos, out1).

TAC_RHS(stmt, cat(cat(cat(baseName, "."), cat(qualifiedName, "(")), cat(out, ")"))) :-
	(VCALL(stmt, base, sig) ; SPCALL(stmt, base, sig)),
	AllOperandsStrDownTo(stmt, -1, out),
	Invocation(sig, _, _, qualifiedName),
	Stmt(stmt, method, _, _),
	VAR(method, base, _, baseName, _).

TAC_RHS(stmt, cat(cat(qualifiedName, "("), cat(out, ")"))) :-
	SCALL(stmt, sig),
	Invocation(sig, _, _, qualifiedName),
	AllOperandsStrDownTo(stmt, -1, out).

// Allocations
TAC_RHS(stmt, cat("new ", type)) :- ALLOC(stmt, _, _, type).

// Static field load
TAC_RHS(stmt, fld) :- SLOAD(stmt, fld).


#define ASSIGN_STR(stmt, to) OperandStr(stmt, -3, to)

TAC(method, index, cat(cat(to, " = "), out)) :-
	ASSIGN_STR(stmt, to),
	Stmt(stmt, method, _, index),
	TAC_RHS(stmt, out).

// Calls without a return value
TAC(method, index, tac) :-
	(VCALL(stmt, _, _) ;
	 SPCALL(stmt, _, _) ;
	 SCALL(stmt, _)),
	Stmt(stmt, method, _, index),
	!ASSIGN_STR(stmt, _),
	TAC_RHS(stmt, tac).

TAC(method, index, "return") :-
	Stmt(stmt, method, _, index),
	RET_VOID(stmt).

TAC(method, index, cat("return ", out)) :-
	Stmt(stmt, method, _, index),
	RET(stmt),
	OperandStr(stmt, 0, out).

TAC(method, index, cat("goto ", to_string(jumpIndex))) :-
	Stmt(stmt, method, _, index),
	GOTO(stmt, jumpStmt),
	Stmt(jumpStmt, method, _, jumpIndex).

TAC(method, index, cat(cat("if (", out), cat(") jump ", to_string(jumpIndex)))) :-
	Stmt(stmt, method, _, index),
	IF(stmt, jumpStmt),
	Stmt(jumpStmt, method, _, jumpIndex),
	TAC_RHS(stmt, out).

TAC(method, index, cat("throw ", varName)) :-
	Stmt(stmt, method, _, index),
	THROW(stmt, var),
	VAR(method, var, _, varName, _).