// Output
.decl ASSIGN(stmt: symbol, to: symbol)
.decl VCALL(stmt: symbol, base: symbol, sig: symbol)
.decl SPCALL(stmt: symbol,  base: symbol, sig: symbol)
.decl ALLOC(stmt: symbol, to: symbol, heap: symbol, type: symbol)
.decl IF(stmt: symbol, jumpStmt: symbol)
.decl GOTO(stmt: symbol, jumpStmt: symbol)
.decl RET(stmt: symbol)
.decl RET_VOID(stmt: symbol)
.decl OPERAND(stmt: symbol, pos: number, from: symbol)
.decl OPERATOR(stmt: symbol, op: symbol)
.decl ACTUAL_PARAM(stmt: symbol, pos: number, op: symbol)
.decl ACTUAL_RET(stmt: symbol, var: symbol)
.decl NEXT(fromStmt: symbol, toStmt: symbol)
.decl THROW(stmt: symbol, var: symbol)
.decl EXCEPTION_HANDLER(method: symbol, fromStmt: symbol, toStmt: symbol, handlerStmt: symbol, type: symbol, var: symbol)

.output ASSIGN
.output VCALL
.output SPCALL
.output ALLOC
.output IF
.output GOTO
.output RET
.output RET_VOID
.output OPERAND
.output OPERATOR
.output ACTUAL_PARAM
.output ACTUAL_RET
//.output NEXT
.output THROW
.output EXCEPTION_HANDLER

// Input
.decl Stmt(id: symbol, method: symbol, index: number)
.decl Opcode(stmt: symbol, opcode: symbol, oper: symbol)
.decl Var(method: symbol, varIndex: symbol, var: symbol, name: symbol, type: symbol, startLabel: symbol, endLable: symbol)
.decl Invocation(sig: symbol, argc: number, retType: symbol)
.decl AllocType(stmt: symbol, type: symbol)
.decl Label(method: symbol, label: symbol, stmt: symbol, index: number)
.decl Handler(method: symbol, startLabel: symbol, endLabel: symbol, handlerLabel: symbol, type: symbol)
.input Stmt
.input Opcode
.input Var
.input Invocation
.input AllocType
.input Label
.input Handler

// Opcodes
.decl BinOpcode(opcode: symbol, op: symbol)
.decl UnaryOpcode(opcode: symbol, op: symbol)
.decl ConstLoadOpcode(opcode: symbol)
.decl CallOpcode(opcode: symbol)
.decl ZeroCondJumpOpcode(opcode: symbol, op: symbol)
.decl NullCondJumpOpcode(opcode: symbol, op: symbol)
.decl CondJumpOpcode(opcode: symbol, op: symbol)

BinOpcode("X-add", "+").
BinOpcode("X-sub", "-").
BinOpcode("X-mul", "*").
BinOpcode("X-div", "/").
BinOpcode("X-rem", "%").
BinOpcode("X-band", "&").
BinOpcode("X-bor", "|").
BinOpcode("X-bxor", "^").
BinOpcode("X-shl", "<<").
BinOpcode("X-shr", ">>").
BinOpcode("X-ushr", ">>>").
BinOpcode("lcmp", "cmp").
BinOpcode("cmpl", "cmp").
BinOpcode("cmpg", "cmp").
UnaryOpcode("X-neg", "-").

ConstLoadOpcode("X-const").
ConstLoadOpcode("ldc").
ConstLoadOpcode("bipush").
ConstLoadOpcode("sipush").
CallOpcode("invokevirtual").
CallOpcode("invokespecial").
CallOpcode("X-invokeinit").

ZeroCondJumpOpcode("ifeq", "==").
ZeroCondJumpOpcode("ifne", "!=").
ZeroCondJumpOpcode("iflt", "<").
ZeroCondJumpOpcode("ifge", ">=").
ZeroCondJumpOpcode("ifgt", ">").
ZeroCondJumpOpcode("ifle", "<=").
NullCondJumpOpcode("ifnull", "==").
NullCondJumpOpcode("ifnonnull", "!=").
CondJumpOpcode("if_icmpeq", "==").
CondJumpOpcode("if_icmpne", "!=").
CondJumpOpcode("if_icmplt", "<").
CondJumpOpcode("if_icmpge", ">=").
CondJumpOpcode("if_icmpgt", ">").
CondJumpOpcode("if_icmple", "<=").
CondJumpOpcode("if_acmpeq", "==").
CondJumpOpcode("if_acmpne", "!=").

///////////////////////////////////////////////////////////////

.type Stack = [top: symbol, rest: Stack]
.decl StackBeforeStmt(stmt: symbol, stack: Stack)
.decl OpcodeExt(stmt: symbol, opcode: symbol, oper: symbol)
.decl ToSymbol(stack: Stack, out: symbol)
.decl DEBUG(stmt: symbol, out: symbol)
.output OpcodeExt
.output DEBUG

.decl __REQ_StackForNext(stmt: symbol, stack: Stack)
.decl __REQ_Var(stmt: symbol, stack: Stack)
.decl __RES_Var(stmt: symbol, var: symbol)
.decl __REQ_ActualParam(stmt: symbol, pos: number, stack: Stack)
.decl __REQ_Assign(stmt: symbol, to: symbol)
.decl __REQ_Operand(stmt: symbol, pos: number, value: symbol)

StackBeforeStmt(stmt, nil) :- Stmt(stmt, _, 0).

ToSymbol(nil, "=@@=") :-
	StackBeforeStmt(_, nil).
ToSymbol([head, stack], cat(head, cat(", ", out0))) :-
	StackBeforeStmt(_, [head, stack]), ToSymbol(stack, out0).
DEBUG(stmt, out) :- StackBeforeStmt(stmt, stack), ToSymbol(stack, out).

// Match load/store statements to variable scopes
// The first store statement of a variable is one index
// before the variable's scope start
OpcodeExt(stmt, opcode, var) :-
	Opcode(stmt, opcode, varIndex),
	(opcode = "X-load" ; opcode = "X-store" ; opcode = "X-inc" ; opcode = "X-dec"),
	Stmt(stmt, method, index),
	Var(method, varIndex, var, _, _, startLabel, endLabel),
	Label(method, startLabel, _, startIndex),
	Label(method, endLabel, _, endIndex),
	(startIndex - 1) <= index, index <= endIndex.

// Exception handlers might introduce unnamed variables
OpcodeExt(stmt, opcode, var) :-
	Opcode(stmt, opcode, varIndex),
	(opcode = "X-load" ; opcode = "X-store"),
	Stmt(stmt, method, _),
	!Var(method, varIndex, _, _, _, _, _),
	var = cat(cat(method, "/"), cat("$throw", varIndex)).

// Assume that the first instruction of a handler is a store
EXCEPTION_HANDLER(method, startStmt, endStmt, handlerStmt, type, var) :-
	Handler(method, startLabel, endLabel, handlerLabel, type),
	Label(method, startLabel, startStmt, _),
	Label(method, endLabel, endStmt, _),
	Label(method, handlerLabel, handlerStmt, _),
	OpcodeExt(handlerStmt, "X-store", var).

IF(stmt, nextStmt),
NEXT(stmt, nextStmt),
OpcodeExt(stmt, opcode, nextStmt) :-
	Opcode(stmt, opcode, label),
	(ZeroCondJumpOpcode(opcode, _) ;
	 NullCondJumpOpcode(opcode, _) ;
	 CondJumpOpcode(opcode, _)),
	Stmt(stmt, method, _),
	Label(method, label, nextStmt, _).

GOTO(stmt, nextStmt),
NEXT(stmt, nextStmt),
OpcodeExt(stmt, "goto", nextStmt) :-
	Opcode(stmt, "goto", label),
	Stmt(stmt, method, _),
	Label(method, label, nextStmt, _).

OpcodeExt(stmt, opcode, oper) :-
	Opcode(stmt, opcode, oper),
	opcode != "X-load",
	opcode != "X-store",
	opcode != "goto",
	!ZeroCondJumpOpcode(opcode, _),
	!NullCondJumpOpcode(opcode, _),
	!CondJumpOpcode(opcode, _).

NEXT(stmt, cat(method, cat("/", to_string(i+1)))) :-
	Opcode(stmt, opcode, _),
	Stmt(stmt, method, i),
	opcode != "goto",
	opcode != "X-return",
	opcode != "return".

///////////////////////////////////////////////////////////////

// -> constant value
__REQ_StackForNext(stmt, [const, stack]) :-
	StackBeforeStmt(stmt, stack),
	OpcodeExt(stmt, opcode, const),
	ConstLoadOpcode(opcode).

// -> value
__REQ_StackForNext(stmt, [var, stack]) :-
	StackBeforeStmt(stmt, stack),
	OpcodeExt(stmt, "X-load", var).

// value ->
__REQ_Assign(stmt, var),
__REQ_Operand(stmt, 0, oper),
__REQ_StackForNext(stmt, stack) :-
	StackBeforeStmt(stmt, [oper, stack]),
	OpcodeExt(stmt, "X-store", var).

// return value ->
RET(stmt),
OPERAND(stmt, 0, oper),
__REQ_StackForNext(stmt, stack) :-
	StackBeforeStmt(stmt, [oper, stack]),
	OpcodeExt(stmt, "X-return", _).

// return void
RET_VOID(stmt),
__REQ_StackForNext(stmt, stack) :-
	StackBeforeStmt(stmt, stack),
	OpcodeExt(stmt, "return", _).

// -> heap id
__REQ_StackForNext(stmt, [heap, stack]) :-
	StackBeforeStmt(stmt, stack),
	OpcodeExt(stmt, "new", heap).

// Dup should only follow a `new` opcode -- ignore it
__REQ_StackForNext(stmt, stack) :-
	StackBeforeStmt(stmt, stack),
	OpcodeExt(stmt, "dup", _).

// Pop call arguments from stack
__REQ_ActualParam(stmt, argc - 1, stack) :-
	StackBeforeStmt(stmt, stack),
	OpcodeExt(stmt, opcode, sig),
	CallOpcode(opcode),
	Invocation(sig, argc, _).

// actual arg1, arg2, ... ->
__REQ_ActualParam(stmt, pos - 1, stack) :-
	__REQ_ActualParam(stmt, pos, [_, stack]), pos >= 0.

ACTUAL_PARAM(stmt, pos, notHeap) :-
	__REQ_ActualParam(stmt, pos, [notHeap, _]), pos >= 0,
	!ALLOC(_, _, notHeap, _).

ACTUAL_PARAM(stmt, pos, var) :-
	__REQ_ActualParam(stmt, pos, [heap, _]), pos >= 0,
	ALLOC(_, var, heap, _).

// receiver object | Class | heap ->
// -> var to store invocation result
__REQ_Var(stmt, stack) :-
	OpcodeExt(stmt, opcode, sig),
	CallOpcode(opcode),
	Invocation(sig, _, retType),
	(retType != "void" ; opcode = "X-invokeinit"),
	__REQ_ActualParam(stmt, -1, [_, stack]).

__REQ_StackForNext(stmt, stack) :-
	OpcodeExt(stmt, opcode, sig),
	CallOpcode(opcode),
	Invocation(sig, _, "void"), opcode != "X-invokeinit",
	__REQ_ActualParam(stmt, -1, [_, stack]).

// Pop receiver object from stack
ALLOC(allocStmt, base, heap, type),
SPCALL(stmt, base, sig) :-
	OpcodeExt(stmt, "X-invokeinit", sig),
	__REQ_ActualParam(stmt, -1, [heap, _]),
	OpcodeExt(allocStmt, "new", heap),
	__RES_Var(stmt, base),
	AllocType(allocStmt, type).

// Pop receiver object from stack
SPCALL(stmt, base, sig) :-
	OpcodeExt(stmt, "invokespecial", sig),
	__REQ_ActualParam(stmt, -1, [base, _]).

// Pop receiver object from stack
VCALL(stmt, base, sig) :-
	OpcodeExt(stmt, "invokevirtual", sig),
	__REQ_ActualParam(stmt, -1, [base, _]).

// Store the top of the stack into a var
// Found in source code
__RES_Var(stmt, var) :-
	__REQ_Var(stmt, _),
	NEXT(stmt, nextStmt),
	OpcodeExt(nextStmt, "X-store", var).

// ...or generate a temp one
__RES_Var(stmt, var) :-
	__REQ_Var(stmt, _),
	Stmt(stmt, method, i),
	NEXT(stmt, nextStmt),
	OpcodeExt(nextStmt, opcode, _),
	opcode != "X-store",
	var = cat(cat(method, "/"), cat("$r", to_string(i))).

// Handle all assignments to temp or source code vars
__REQ_Assign(stmt, var),
__REQ_StackForNext(stmt, [var, stack]) :-
	__REQ_Var(stmt, stack),
	__RES_Var(stmt, var).

// Compute an intermediate result
// Swap order of operands due to stack semantics
OPERATOR(stmt, op),
OPERAND(stmt, 0, oper0),
OPERAND(stmt, 1, oper1),
__REQ_Var(stmt, stack) :-
	StackBeforeStmt(stmt, [oper1, [oper0, stack]]),
	OpcodeExt(stmt, opcode, _),
	BinOpcode(opcode, op).

OPERATOR(stmt, op),
OPERAND(stmt, 0, oper),
__REQ_Var(stmt, stack) :-
	StackBeforeStmt(stmt, [oper, stack]),
	OpcodeExt(stmt, opcode, _),
	UnaryOpcode(opcode, op).

//// Handle ++ or --
//ASSIGN(stmt, var),
//OPERATOR(stmt, op),
//OPERAND(stmt, 0, var),
//OPERAND(stmt, 1, "1"),
//__REQ_StackForNext(stmt, stack) :-
//	StackBeforeStmt(stmt, stack),
//	((OpcodeExt(stmt, "X-inc", var), op = "+") ;
//	 (OpcodeExt(stmt, "X-dec", var), op = "-")).

//// Load static field
//OPERAND(stmt, 0, oper1),
//__REQ_Var(stmt, stack) :-
//	StackBeforeIndex(stmt, stack),
//	OpcodeExt(stmt, "getstatic", oper1).
//
//PopOpcode("pop").
//PopOpcode("pop2").
//__StackForNext(method, i, stack) :-
//	StackBeforeIndex(method, i, [_, stack]),
//	OpcodeExt(method, i, opcode, _),
//	PopOpcode(opcode).

// Handle conditional jumps
OPERATOR(stmt, op),
OPERAND(stmt, 0, oper0),
OPERAND(stmt, 1, oper1),
__REQ_StackForNext(stmt, stack) :-
	StackBeforeStmt(stmt, [oper0, stack]),
	OpcodeExt(stmt, opcode, _),
	((ZeroCondJumpOpcode(opcode, op), oper1 = "0") ;
	 (NullCondJumpOpcode(opcode, op), oper1 = "NULL")).

OPERATOR(stmt, op),
OPERAND(stmt, 0, oper0),
OPERAND(stmt, 1, oper1),
__REQ_StackForNext(stmt, stack) :-
	StackBeforeStmt(stmt, [oper1, [oper0, stack]]),
	OpcodeExt(stmt, opcode, _),
	CondJumpOpcode(opcode, op).

// ... and unconditional ones
__REQ_StackForNext(stmt, stack) :-
	StackBeforeStmt(stmt, stack),
	OpcodeExt(stmt, "goto", _).

// Prepare stack for an exception handler
StackBeforeStmt(handlerStmt, [type, nil]) :-
	EXCEPTION_HANDLER(_, _, _, handlerStmt, type, _).

THROW(stmt, var),
__REQ_StackForNext(stmt, stack) :-
	StackBeforeStmt(stmt, [var, stack]),
	OpcodeExt(stmt, "athrow", _).

///////////////////////////////////////////////////////////////

StackBeforeStmt(nextStmt, stack) :-
	__REQ_StackForNext(stmt, stack),
	NEXT(stmt, nextStmt).

// Approve all assignments, except self-assign ones
ASSIGN(stmt, to) :-
	__REQ_Assign(stmt, to),
	!__REQ_Operand(stmt, 0, to).

OPERAND(stmt, pos, oper) :-
	__REQ_Operand(stmt, pos, oper),
	ASSIGN(stmt, _).

ACTUAL_RET(stmt, var) :-
	__REQ_Assign(stmt, var),
	OpcodeExt(stmt, opcode, _),
	CallOpcode(opcode).

///////////////////////////////////////////////////////////////

// Starting and ending statements for each Basic Block
.decl BB_Start(method: symbol, stmt: symbol, index: number)
.decl BB_End(method: symbol, stmt: symbol, index: number)
.decl BB_Range(startStmt: symbol, endStmt: symbol)
// Forward paths regarding Basic Blocks
// Each Basic Block is represented by its starting statement
// Paths will be used in dominance, hence BB with back-edges
// certainly do not dominate the head BB
.decl BB_FW_Edge(from: symbol, to: symbol)
.decl BB_FW_Path(from: symbol, to: symbol)
// `from` dominates `to` iff every path from entry to `to` includes `from`
.decl BB_DOM_Fail(from: symbol, to: symbol)
.decl BB_DOM(from: symbol, to: symbol)
// `from` immediate dominates `to` iff `from` dominates `to`
// and there does not exists a node `middle` such that
// `from` dominates `middle` and `middle` dominates `to`
.decl BB_IDOM_Fail(from: symbol, to: symbol)
.decl BB_IDOM(from: symbol, to: symbol)
// Calculate the dominance frontier of each basic block
// Direct computation is quadratic, but a linear algorithm
// uses two intermediate components, DF_Local and DF_Upto
// DF(x) = { y | (exists z in Pred(y) such that x dom z) && x !sdom y }
.decl BB_DF(fromBB: symbol, toBB: symbol)
.decl BB_DF_Local(fromBB: symbol, toBB: symbol)
.decl BB_DF_Upto(fromBB: symbol, middleBB: symbol, toBB: symbol)
.output BB_Range
//.output BB_DOM_Fail
//.output BB_DOM
//.output BB_IDOM_Fail
.output BB_IDOM
.output BB_DF
//.output BB_DF_Local
//.output BB_DF_Upto

// First statement starts a BB
BB_Start(method, stmt, 0) :- Stmt(stmt, method, 0).

// Return statements end a BB
BB_End(method, stmt, index) :-
	(OpcodeExt(stmt, "X-return", _) ;
	 OpcodeExt(stmt, "return", _)),
	Stmt(stmt, method, index).

// A BB ends at a jump,
// and another starts at the target label
BB_End(method, stmt, index),
BB_Start(method, targetStmt, targetIndex) :-
	OpcodeExt(stmt, opcode, targetStmt),
	(ZeroCondJumpOpcode(opcode, _) ;
	 NullCondJumpOpcode(opcode, _) ;
	 CondJumpOpcode(opcode, _) ;
	 opcode = "goto"),
	Stmt(stmt, method, index),
	Stmt(targetStmt, method, targetIndex).

// Whenever a BB ends, another starts
BB_Start(method, startStmt, startIndex) :-
	BB_End(method, endStmt, _),
	NEXT(endStmt, startStmt),
	Stmt(startStmt, method, startIndex).

// Whenever a BB starts, another ends
BB_End(method, endStmt, endIndex) :-
	BB_Start(method, startStmt, _),
	NEXT(endStmt, startStmt),
	Stmt(endStmt, method, endIndex).

// The ending statement of a Basic Block is
// the closest ending statement after the starting statement
BB_Range(startStmt, endStmt) :-
	BB_Start(method, startStmt, startIndex),
	BB_End(method, endStmt, endIndex),
	endIndex = min index : { BB_End(method, _, index), index >= startIndex }.

BB_FW_Edge(from, to) :-
	BB_Range(from, endStmt),
	Stmt(endStmt, method, endIndex),
	NEXT(endStmt, to),
	BB_Start(method, to, toIndex),
	endIndex < toIndex.

BB_FW_Path(from, to) :-
	BB_FW_Edge(from, to).

BB_FW_Path(from, to) :-
	BB_FW_Path(from, middle),
	BB_FW_Edge(middle, to).

// Simulate forall
// There are two paths to a basic block and
// one is not a sub-path of the other
BB_DOM_Fail(from1, to),
BB_DOM_Fail(from2, to) :-
	BB_FW_Path(from1, to),
	BB_FW_Path(from2, to),
	from1 != from2,
	!BB_FW_Path(from1, from2),
	!BB_FW_Path(from2, from1).

BB_DOM(from, to) :-
	BB_FW_Path(from, to),
	!BB_DOM_Fail(from, to).

// Simulate forall
BB_IDOM_Fail(from, to) :-
	BB_DOM(from, to),
	BB_DOM(from, middle),
	BB_DOM(middle, to).

BB_IDOM(from, to) :-
	BB_DOM(from, to),
	!BB_IDOM_Fail(from, to).

// DF_Local(x) = { y in Succ(x) | x !idom y }
BB_DF_Local(x, y) :-
	BB_Range(x, endStmt),
	NEXT(endStmt, y),
	!BB_IDOM(x, y).

// DF_Upto(x, z) = { y in DF(z) | x idom z && x !idom y }
BB_DF_Upto(x, z, y) :-
	BB_DF(z, y),
	BB_IDOM(x, z),
	!BB_IDOM(x, y).

// DF(x) = DF_Local(x) U ...
BB_DF(x, y) :-
	BB_DF_Local(x, y).

// ... U{z such that x idom z} DF_Upto(x, z)
BB_DF(x, y) :-
	BB_IDOM(x, z),
	BB_DF_Upto(x, z, y).



