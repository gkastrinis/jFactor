// Output
.decl ASSIGN(method: symbol, index: number, to: symbol)
.decl OPERAND(method: symbol, index: number, pos: number, from: symbol)
.decl OPERATOR(method: symbol, index: number, op: symbol)
.decl VCALL(method: symbol, index: number, base: symbol, sig: symbol)
.decl SPCALL(method: symbol, index: number, base: symbol, sig: symbol)
.decl ACTUAL_PARAM(method: symbol, index: number, pos: number, var: symbol)
.decl FORMAL_RET(method: symbol, index: number, op: symbol)
.decl FORMAL_RET_VOID(method: symbol, index: number)
.decl ACTUAL_RET(method: symbol, index: number, var: symbol)
.decl ALLOC(method: symbol, index: number, to: symbol, heap: symbol, type: symbol)
.decl IF(method: symbol, index: number, toIndex: number)
.decl GOTO(method: symbol, index: number, toIndex: number)
.output ASSIGN
.output OPERAND
.output OPERATOR
.output VCALL
.output SPCALL
.output ACTUAL_PARAM
.output FORMAL_RET
.output FORMAL_RET_VOID
.output ACTUAL_RET
.output ALLOC
.output IF
.output GOTO

// Input
.decl Opcode(method: symbol, index: number, opcode: symbol, oper: symbol)
.decl Var(method: symbol, index: symbol, var: symbol, name: symbol, type: symbol)
.decl Invocation(sig: symbol, argc: number, retType: symbol)
.decl AllocType(method: symbol, index: number, type: symbol)
.decl Label(method: symbol, label: symbol, index: number)
.input Opcode
.input Var
.input Invocation
.input AllocType
.input Label

// Opcodes
.decl BinOpcode(opcode: symbol, op: symbol)
.decl UnaryOpcode(opcode: symbol, op: symbol)
.decl ConstLoadOpcode(opcode: symbol)
.decl CallOpcode(opcode: symbol)
.decl PopOpcode(opcode: symbol)
.decl ZeroCondJumpOpcode(opcode: symbol, op: symbol)
.decl NullCondJumpOpcode(opcode: symbol, op: symbol)
.decl CondJumpOpcode(opcode: symbol, op: symbol)
.decl JumpOpcode(opcode: symbol)

BinOpcode("X-add", "+").
BinOpcode("X-sub", "-").
BinOpcode("X-mul", "*").
BinOpcode("X-div", "/").
BinOpcode("X-rem", "%").
BinOpcode("X-band", "&").
BinOpcode("X-bor", "|").
BinOpcode("X-bxor", "^").
BinOpcode("X-shl", "<<").
BinOpcode("X-shr", ">>").
BinOpcode("X-ushr", ">>>").
BinOpcode("lcmp", "cmp").
BinOpcode("cmpl", "cmp").
BinOpcode("cmpg", "cmp").
UnaryOpcode("X-neg", "-").

ConstLoadOpcode("X-const").
ConstLoadOpcode("ldc").
ConstLoadOpcode("bipush").
ConstLoadOpcode("sipush").
CallOpcode("invokevirtual").
CallOpcode("invokespecial").
CallOpcode("X-invokeinit").

PopOpcode("pop").
PopOpcode("pop2").

ZeroCondJumpOpcode("ifeq", "==").
ZeroCondJumpOpcode("ifne", "!=").
ZeroCondJumpOpcode("iflt", "<").
ZeroCondJumpOpcode("ifge", ">=").
ZeroCondJumpOpcode("ifgt", ">").
ZeroCondJumpOpcode("ifle", "<=").
NullCondJumpOpcode("ifnull", "==").
NullCondJumpOpcode("ifnonnull", "!=").
CondJumpOpcode("if_icmpeq", "==").
CondJumpOpcode("if_icmpne", "!=").
CondJumpOpcode("if_icmplt", "<").
CondJumpOpcode("if_icmpge", ">=").
CondJumpOpcode("if_icmpgt", ">").
CondJumpOpcode("if_icmple", "<=").
CondJumpOpcode("if_acmpeq", "==").
CondJumpOpcode("if_acmpne", "!=").
JumpOpcode("goto").

///////////////////////////////////////////////////////////////

.type Stack = [top: symbol, rest: Stack]
.decl StackBeforeIndex(method: symbol, index: number, stack: Stack)
.decl Next(method: symbol, from: number, to: number)

StackBeforeIndex(method, 0, nil) :- Opcode(method, _, _, _).

.decl ToSymbol(stack: Stack, out: symbol)
.decl DEBUG(m: symbol, i: number, out: symbol)
.output DEBUG
ToSymbol(nil, "=@@=") :- StackBeforeIndex(_, _, nil).
ToSymbol([head, stack], cat(head, cat(", ", out0))) :- StackBeforeIndex(_, _, [head, stack]), ToSymbol(stack, out0).
DEBUG(m, i, out) :- StackBeforeIndex(m, i, stack), ToSymbol(stack, out).

.decl __REQ_StackForNext(method: symbol, fromIndex: number, stack: Stack)
.decl __REQ_Var(method: symbol, index: number, stack: Stack)
.decl __RES_Var(method: symbol, index: number, var: symbol)
.decl __REQ_ActualParam(method: symbol, index: number, pos: number, stack: Stack)
.decl __REQ_Assign(method: symbol, index: number, to: symbol)
.decl __REQ_Operand(method: symbol, index: number, pos: number, value: symbol)
.decl __VarFromIndex(method: symbol, index: symbol, var: symbol)
.decl __HeapToIndex(heap: symbol, method: symbol, index: number)
//.output Next

///////////////////////////////////////////////////////////////

// -> constant value
__REQ_StackForNext(method, i, [const, stack]) :-
	StackBeforeIndex(method, i, stack),
	Opcode(method, i, opcode, const),
	ConstLoadOpcode(opcode).

// -> value
__REQ_StackForNext(method, i, [var, stack]) :-
	StackBeforeIndex(method, i, stack),
	Opcode(method, i, "X-load", varIndex),
	__VarFromIndex(method, varIndex, var).

// value ->
__REQ_Assign(method, i, var),
__REQ_Operand(method, i, 0, oper),
__REQ_StackForNext(method, i, stack) :-
	StackBeforeIndex(method, i, [oper, stack]),
	Opcode(method, i, "X-store", index),
	__VarFromIndex(method, index, var).

// return value ->
FORMAL_RET(method, i, oper),
__REQ_StackForNext(method, i, stack) :-
	StackBeforeIndex(method, i, [oper, stack]),
	Opcode(method, i, "X-return", _).

// return void
FORMAL_RET_VOID(method, i),
__REQ_StackForNext(method, i, stack) :-
	StackBeforeIndex(method, i, stack),
	Opcode(method, i, "X-return-void", _).

// -> heap id
__HeapToIndex(heap, method, i),
__REQ_StackForNext(method, i, [heap, stack]) :-
	StackBeforeIndex(method, i, stack),
	Opcode(method, i, "new", heap).

// Dup should only follow a `new` opcode -- ignore it
__REQ_StackForNext(method, i, stack) :-
	StackBeforeIndex(method, i, stack),
	Opcode(method, i, "dup", _).

// Pop call arguments from stack
__REQ_ActualParam(method, i, argc - 1, stack) :-
	StackBeforeIndex(method, i, stack),
	Opcode(method, i, opcode, sig),
	CallOpcode(opcode),
	Invocation(sig, argc, _).

// actual arg1, arg2, ... ->
__REQ_ActualParam(method, i, pos - 1, stack) :-
	__REQ_ActualParam(method, i, pos, [_, stack]), pos >= 0.

ACTUAL_PARAM(method, i, pos, notHeap) :-
	__REQ_ActualParam(method, i, pos, [notHeap, _]), pos >= 0,
	!ALLOC(_, _, _, notHeap, _).

ACTUAL_PARAM(method, i, pos, var) :-
	__REQ_ActualParam(method, i, pos, [heap, _]), pos >= 0,
	ALLOC(_, _, var, heap, _).

// receiver object | Class | heap ->
// -> var to store invocation result
__REQ_Var(method, i, stack) :-
	Opcode(method, i, opcode, sig),
	CallOpcode(opcode),
	Invocation(sig, _, retType),
	(retType != "void" ; opcode = "X-invokeinit"),
	__REQ_ActualParam(method, i, -1, [_, stack]).

__REQ_StackForNext(method, i, stack) :-
	Opcode(method, i, opcode, sig),
	CallOpcode(opcode),
	Invocation(sig, _, "void"), opcode != "X-invokeinit",
	__REQ_ActualParam(method, i, -1, [_, stack]).

// Pop receiver object from stack
//ASSIGN(method, i, base),
//OPERAND(method, i, 0, heap),
ALLOC(method, j, base, heap, type),
SPCALL(method, i, base, sig) :-
	Opcode(method, i, "X-invokeinit", sig),
	__REQ_ActualParam(method, i, -1, [heap, _]),
	__HeapToIndex(heap, method, j),
	__RES_Var(method, i, base),
	AllocType(method, j, type).

// Pop receiver object from stack
SPCALL(method, i, base, sig) :-
	Opcode(method, i, "invokespecial", sig),
	__REQ_ActualParam(method, i, -1, [base, _]).

// Pop receiver object from stack
VCALL(method, i, base, sig) :-
	Opcode(method, i, "invokevirtual", sig),
	__REQ_ActualParam(method, i, -1, [base, _]).

// Store the top of the stack into a var
// Found in source code
__RES_Var(method, i, var) :-
	__REQ_Var(method, i, _),
	Opcode(method, i+1, "X-store", varIndex),
	__VarFromIndex(method, varIndex, var).

// ...or generate a temp one
__RES_Var(method, i, var) :-
	__REQ_Var(method, i, _),
	Opcode(method, i+1, opcode, _),
	opcode != "X-store",
	var = cat(cat(method, "/"), cat("$r", to_string(i))).

// Handle all assignments to temp or source code vars
__REQ_Assign(method, i, var),
__REQ_StackForNext(method, i, [var, stack]) :-
	__REQ_Var(method, i, stack),
	__RES_Var(method, i, var).

// Compute an intermediate result
// Swap order of operands due to stack semantics
OPERATOR(method, i, op),
__REQ_Operand(method, i, 0, oper2),
__REQ_Operand(method, i, 1, oper1),
__REQ_Var(method, i, stack) :-
	StackBeforeIndex(method, i, [oper1, [oper2, stack]]),
	Opcode(method, i, opcode, _),
	BinOpcode(opcode, op).

OPERATOR(method, i, op),
__REQ_Operand(method, i, 0, oper),
__REQ_Var(method, i, stack) :-
	StackBeforeIndex(method, i, [oper, stack]),
	Opcode(method, i, opcode, _),
	UnaryOpcode(opcode, op).

//// Load static field
//OPERAND(method, i, 0, oper1),
//__REQ_Var(method, i, stack) :-
//	StackBeforeIndex(method, i, stack),
//	Opcode(method, i, "getstatic", oper1).
//
//// TODO might be problematic
//__StackForNext(method, i, stack) :-
//	StackBeforeIndex(method, i, [_, stack]),
//	Opcode(method, i, opcode, _),
//	PopOpcode(opcode).

// Handle conditional jumps
IF(method, i, j),
OPERATOR(method, i, op),
__REQ_Operand(method, i, 0, oper),
__REQ_Operand(method, i, 1, oper1),
__REQ_StackForNext(method, i, stack) :-
	StackBeforeIndex(method, i, [oper, stack]),
	Opcode(method, i, opcode, _),
	((ZeroCondJumpOpcode(opcode, op), oper1 = "0") ;
	 (NullCondJumpOpcode(opcode, op), oper1 = "NULL")),
	Next(method, i, j).

IF(method, i, j),
OPERATOR(method, i, op),
__REQ_Operand(method, i, 0, oper1),
__REQ_Operand(method, i, 1, oper2),
__REQ_StackForNext(method, i, stack) :-
	StackBeforeIndex(method, i, [oper2, [oper1, stack]]),
	Opcode(method, i, opcode, _),
	CondJumpOpcode(opcode, op),
	Next(method, i, j).

// ... and unconditional ones
GOTO(method, i, j),
__REQ_StackForNext(method, i, stack) :-
	StackBeforeIndex(method, i, stack),
	Opcode(method, i, opcode, _),
	JumpOpcode(opcode),
	Next(method, i, j).

///////////////////////////////////////////////////////////////

__VarFromIndex(method, i, var) :- Var(method, i, var, _, _).

Next(method, i, j) :-
	Opcode(method, i, opcode, label),
	(ZeroCondJumpOpcode(opcode, _) ;
	 NullCondJumpOpcode(opcode, _) ;
	 CondJumpOpcode(opcode, _) ;
	 JumpOpcode(opcode)),
	Label(method, label, j).

Next(method, i, i+1) :-
	Opcode(method, i, opcode, _),
	!JumpOpcode(opcode).

StackBeforeIndex(method, j, stack) :-
	__REQ_StackForNext(method, i, stack),
	Next(method, i, j).

// Approve all assignments, except self-assign ones
ASSIGN(method, i, to) :-
	__REQ_Assign(method, i, to),
	!__REQ_Operand(method, i, 0, to).

OPERAND(method, i, pos, oper) :-
	__REQ_Operand(method, i, pos, oper),
	(ASSIGN(method, i, _) ; IF(method, i, _)).

ACTUAL_RET(method, i, var) :-
	__REQ_Assign(method, i, var),
	Opcode(method, i, opcode, _),
	CallOpcode(opcode).
