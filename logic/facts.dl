// Input
.decl Opcode(method: symbol, index: number, opcode: symbol, oper: symbol)
.decl Var(method: symbol, index: symbol, var: symbol, type: symbol)
.decl MethodSig(sig: symbol, argc: number, retType: symbol)
.input Opcode
.input Var
.input MethodSig
// Output
.decl ASSIGN(method: symbol, index: number, to: symbol)
.decl OPERAND(method: symbol, index: number, pos: number, from: symbol)
.decl OPERATOR(method: symbol, index: number, op: symbol)
.decl VCALL(method: symbol, index: number, base: symbol, sig: symbol)
.decl SPCALL(method: symbol, index: number, base: symbol, sig: symbol)
.decl ACTUAL_PARAM(method: symbol, index: number, pos: number, var: symbol)
.decl RETURN(method: symbol, index: number, op: symbol)
.output ASSIGN
.output OPERAND
.output OPERATOR
.output VCALL
.output SPCALL
.output ACTUAL_PARAM
.output RETURN
///////////////////////////////////////////////////////////////

.type Stack = [top: symbol, rest: Stack]
.decl StackBeforeIndex(method: symbol, index: number, stack: Stack)

//.decl UnaryConsumer(opcode: symbol)
.decl BinOpcode(opcode: symbol, op: symbol)
.decl VarLoadOpcode(opcode: symbol)
.decl VarStoreOpcode(opcode: symbol)
.decl ConstLoadOpcode(opcode: symbol)
.decl ReturnValueOpcode(opcode: symbol)
.decl CallOpcode(opcode: symbol)
.decl PopOpcode(opcode: symbol)
.decl HackOpcode(opcode: symbol)

BinOpcode("dmul", "*").

VarLoadOpcode("aload").
VarLoadOpcode("iload").
VarLoadOpcode("fload").
VarLoadOpcode("dload").
VarStoreOpcode("dstore").
ConstLoadOpcode("ldc").
ConstLoadOpcode("bipush").
ConstLoadOpcode("sipush").
ReturnValueOpcode("ireturn").
ReturnValueOpcode("dreturn").
CallOpcode("invokevirtual").
CallOpcode("invokespecial").

HackOpcode("dup").
PopOpcode("pop").
PopOpcode("pop2").


.decl __REQ_Var(method: symbol, index: number, stack: Stack)
.decl __RES_Var(method: symbol, index: number, var: symbol)
.decl __PROC_Param(method: symbol, index: number, pos: number, arity: number, stack: Stack)


StackBeforeIndex(method, 0, nil) :- Opcode(method, _, _, _).

// Push var into stack
StackBeforeIndex(method, i+1, [var, stack]) :-
	StackBeforeIndex(method, i, stack),
	Opcode(method, i, opcode, varIndex),
	VarLoadOpcode(opcode),
	Var(method, varIndex, var, _).

// Compute an intermediate result
// Swap order of operands due to stack semantics
OPERAND(method, i, 0, oper2),
OPERAND(method, i, 1, oper1),
OPERATOR(method, i, op),
__REQ_Var(method, i, stack) :-
	StackBeforeIndex(method, i, [oper1, [oper2, stack]]),
	Opcode(method, i, opcode, _),
	BinOpcode(opcode, op).

OPERAND(method, i, 0, oper1),
__REQ_Var(method, i, stack) :-
	StackBeforeIndex(method, i, stack),
	Opcode(method, i, "getstatic", oper1).

// Store top of stack into a var (found in source code, or temp)
__RES_Var(method, i, var) :-
	__REQ_Var(method, i, _),
	Opcode(method, i+1, opcode, varIndex),
	VarStoreOpcode(opcode),
	Var(method, varIndex, var, _).

__RES_Var(method, i, var) :-
	__REQ_Var(method, i, _),
	Opcode(method, i+1, opcode, _),
	!VarStoreOpcode(opcode),
	var = cat("$var", to_string(i)).

ASSIGN(method, i, var),
StackBeforeIndex(method, i+1, [var, stack]) :-
	__REQ_Var(method, i, stack),
	__RES_Var(method, i, var).

// Pop (and ignore) the top operand in the stack
// Already handled in the previous opcode
StackBeforeIndex(method, i+1, stack) :-
	StackBeforeIndex(method, i, [_, stack]),
	Opcode(method, i, opcode, _),
	VarStoreOpcode(opcode).

// Pop call arguments from stack
__PROC_Param(method, i, argc - 1, argc, stack) :-
	StackBeforeIndex(method, i, stack),
	Opcode(method, i, opcode, sig),
	CallOpcode(opcode),
	MethodSig(sig, argc, _).

ACTUAL_PARAM(method, i, pos, param),
__PROC_Param(method, i, pos - 1, arity, stack) :-
	__PROC_Param(method, i, pos, arity, [param, stack]), pos >= 0.

// Pop call receiver from stack
VCALL(method, i, base, sig) :-
	Opcode(method, i, "invokevirtual", sig),
	__PROC_Param(method, i, -1, _, [base, _]).

// Pop call receiver from stack
SPCALL(method, i, base, sig) :-
	Opcode(method, i, "invokespecial", sig),
	__PROC_Param(method, i, -1, _, [base, _]).

StackBeforeIndex(method, i+1, stack) :-
	Opcode(method, i, opcode, sig),
	CallOpcode(opcode),
	MethodSig(sig, _, "void"),
	__PROC_Param(method, i, -1, _, [_, stack]).

// Push var for call result
__REQ_Var(method, i, stack) :-
	Opcode(method, i, opcode, sig),
	CallOpcode(opcode),
	MethodSig(sig, _, retType),
	retType != "void",
	__PROC_Param(method, i, -1, _, [_, stack]).

// Push constant value into stack
StackBeforeIndex(method, i+1, [const, stack]) :-
	StackBeforeIndex(method, i, stack),
	Opcode(method, i, opcode, const),
	ConstLoadOpcode(opcode).

RETURN(method, i, oper),
StackBeforeIndex(method, i+1, stack) :-
	StackBeforeIndex(method, i, [oper, stack]),
	Opcode(method, i, opcode, _),
	ReturnValueOpcode(opcode).


// TODO might be problematic
StackBeforeIndex(method, i+1, stack) :-
	StackBeforeIndex(method, i, [_, stack]),
	Opcode(method, i, opcode, _),
	PopOpcode(opcode).
StackBeforeIndex(method, i+1, stack) :-
	StackBeforeIndex(method, i, stack),
	Opcode(method, i, opcode, _),
	HackOpcode(opcode).


.decl DEBUG_STACK(stack: Stack, out: symbol)
.decl DEBUG(m: symbol, i: number, out: symbol)
.output DEBUG
DEBUG_STACK(nil, "=@@=") :- StackBeforeIndex(_, _, nil).
DEBUG_STACK([head, stack], cat(head, cat(", ", out0))) :- StackBeforeIndex(_, _, [head, stack]), DEBUG_STACK(stack, out0).
DEBUG(m, i, out) :- StackBeforeIndex(m, i, stack), DEBUG_STACK(stack, out).
