#pragma once
#include "schema.dl"
#include "basic-blocks.dl"

// The beginning of basic-block `inBB` needs a phi-node for variable `var`
// A phi-node might implicate multiple operands, and in the end expand
// into multiple assignments
.decl PHI_HyperStmt(inBB: symbol, var: symbol)
.decl VarAliveAtStartOfBB(var: symbol, ssaVar: symbol, inBB: symbol)
.decl VarAliveAtEndOfBB(var: symbol, ssaVar: symbol, inBB: symbol)
.decl OperandHasDefInBB(stmt: symbol, var: symbol, ssaVar: symbol)
.decl __Rename(stmt: symbol, var: symbol, ssaVar: symbol, ssaName: symbol, index: number, inBB: symbol)

p2_VarInfo(ssaVar, ssaName, var),
p2_Assign(stmt, var, ssaVar, index, inBB) :-
	__Rename(stmt, var, ssaVar, ssaName, index, inBB),
	!TempVar(var, _).

// Skip renaming of temp vars. They are assigned only once
p2_VarInfo(var, name, var),
p2_Assign(stmt, var, var, index, inBB) :-
	__Rename(stmt, var, _, _, index, inBB),
	TempVar(var, name).

// Mock assignments to formal parameters,
// so they are treated uniformly in the rest of the SSA logic
// Mock assignments are placed in the fake prologue BB
__Rename(stmt, var, var, name, PROLOGUE_INDEX, stmt) :-
	FORMAL_PARAM(method, _, var),
	BB_Start(method, stmt, PROLOGUE_INDEX),
	p1_Var(_, var, _, name).

// Rename all various "source" var assigns
__Rename(stmt, var, ssaVar, ssaName, index, startStmt) :-
	(p1_Assign(stmt, var) ;
	 p1_Alloc(stmt, var, _, _)),
//	 p1_VCall(stmt, var, _) ;
//	 p1_SPCall(stmt, var, _) ;
//	 p1_Throw(stmt, var)),
	BytecodeStmt(stmt, method, index),
	BB_Range(method, startStmt, _, startIndex, endIndex),
	startIndex <= index, index <= endIndex,
	p1_Var(_, var, _, name),
	suffix = cat("#_", to_string(index)),
	ssaVar = cat(var, suffix), ssaName = cat(name, suffix).

// New var assignment at every Phi
// Add a Phi node only when there are multiple assignments
PHI_HyperStmt(toBB, var),
__Rename(toBB, var, ssaVar, ssaName, startIndex, toBB) :-
	p2_Assign(_, var, _, _, fromBB1),
	BB_DominanceFrontier(fromBB1, toBB),
	p2_Assign(_, var, _, _, fromBB2),
	fromBB1 != fromBB2,
	p1_VarRange(var, varStart, varEnd),
	BB_Start(_, toBB, startIndex),
	varStart <= startIndex, startIndex <= varEnd,
	p1_Var(_, var, _, name),
	suffix = cat("#_PHI_", to_string(startIndex)),
	ssaVar = cat(var, suffix), ssaName = cat(name, suffix).

VarAliveAtStartOfBB(var, ssaVar, toBB) :-
	BB_Range(_, fromBB, endStmt, _, _),
	VarAliveAtEndOfBB(var, ssaVar, fromBB),
	p1_Next(endStmt, toBB),
	BB_Start(_, toBB, toBBIndex),
	p1_VarRange(var, varStart, varEnd),
	varStart <= toBBIndex, toBBIndex <= varEnd.

VarAliveAtEndOfBB(var, ssaVar, inBB) :-
	p2_Assign(_, var, ssaVar, maxIndex, inBB),
	maxIndex = max index : p2_Assign(_, var, _, index, inBB).

VarAliveAtEndOfBB(var, ssaVar, inBB) :-
	BB_Start(_, inBB, _),
	VarAliveAtStartOfBB(var, ssaVar, inBB),
	!p2_Assign(_, var, _, _, inBB).

p2_Operand(inBB, 0, ssaVar) :-
	PHI_HyperStmt(inBB, var),
	VarAliveAtStartOfBB(var, ssaVar, inBB).

p2_Operand(stmt, pos, ssaVar),
OperandHasDefInBB(stmt, var, ssaVar) :-
	p1_Operand(stmt, pos, _, var),
	BytecodeStmt(stmt, _, index),
	BytecodeStmtInBB(stmt, inBB),
	p2_Assign(_, var, ssaVar, maxMinIndex, inBB),
	maxMinIndex = max minIndex : { p2_Assign(_, var, ssaVar, minIndex, inBB), minIndex < index }.

p2_Operand(stmt, pos, ssaVar) :-
	p1_Operand(stmt, pos, _, var),
	BytecodeStmtInBB(stmt, inBB),
	!OperandHasDefInBB(stmt, var, _),
	VarAliveAtStartOfBB(var, ssaVar, inBB).

// Deal with constant operands
p2_Operand(stmt, pos, var) :-
	p1_Operand(stmt, pos, _, var),
	BytecodeStmtInBB(stmt, inBB),
	!OperandHasDefInBB(stmt, var, _),
	!VarAliveAtStartOfBB(var, _, inBB).