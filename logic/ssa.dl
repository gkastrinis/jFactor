#pragma once
#include "schema.dl"

// Starting and ending statements for each Basic Block
.decl BB_Start(method: symbol, stmt: symbol, index: number)
.decl BB_End(method: symbol, stmt: symbol, index: number)
.decl BB_Range(method: symbol, startStmt: symbol, endStmt: symbol, startIndex: number, endIndex: number)
// Forward paths regarding Basic Blocks
// Each Basic Block is represented by its starting statement
// Paths will be used in dominance, hence BB with back-edges
// certainly do not dominate the head BB
.decl BB_FW_Edge(from: symbol, to: symbol)
.decl BB_FW_Path(from: symbol, to: symbol)
/* Chapter 8, Advanced Compiler Design & Implementation, Steven Muchnick */
// `from` dominates `to` iff every path from entry to `to` includes `from`
.decl BB_DOM_Fail(from: symbol, to: symbol)
.decl BB_DOM(from: symbol, to: symbol)
// `from` immediate dominates `to` iff `from` dominates `to`
// and there does not exists a node `middle` such that
// `from` dominates `middle` and `middle` dominates `to`
.decl BB_IDOM_Fail(from: symbol, to: symbol)
.decl BB_IDOM(from: symbol, to: symbol)
// Calculate the dominance frontier of each basic block
// Direct computation is quadratic, but a linear algorithm
// uses two intermediate components, DF_Local and DF_Upto
// DF(x) = { y | (exists z in Pred(y) such that x dom z) && x !sdom y }
.decl BB_DominanceFrontier(fromBB: symbol, toBB: symbol)
.decl BB_DF_Local(fromBB: symbol, toBB: symbol)
.decl BB_DF_Upto(fromBB: symbol, middleBB: symbol, toBB: symbol)

// First statement starts a BB
BB_Start(method, stmt, 0) :- Stmt(stmt, method, 0).

// Return and throw statements end a BB
BB_End(method, stmt, index) :-
	(OpcodeExt(stmt, "X-return", _) ;
	 OpcodeExt(stmt, "return", _) ;
	 OpcodeExt(stmt, "athrow", _)),
	Stmt(stmt, method, index).

// A BB ends at a jump,
// and another starts at the target label
BB_End(method, stmt, index),
BB_Start(method, targetStmt, targetIndex) :-
	OpcodeExt(stmt, opcode, targetStmt),
	(ZeroCondJumpOpcode(opcode, _) ;
	 NullCondJumpOpcode(opcode, _) ;
	 CondJumpOpcode(opcode, _) ;
	 opcode = "goto"),
	Stmt(stmt, method, index),
	Stmt(targetStmt, method, targetIndex).

// Whenever a BB ends, another starts
BB_Start(method, startStmt, startIndex) :-
	BB_End(method, endStmt, _),
	NEXT(endStmt, startStmt),
	Stmt(startStmt, method, startIndex).

// Whenever a BB starts, another ends
BB_End(method, endStmt, endIndex) :-
	BB_Start(method, startStmt, _),
	NEXT(endStmt, startStmt),
	Stmt(endStmt, method, endIndex).

// Each exception handler starts a basic block
BB_Start(method, startStmt, startIndex) :-
	EXCEPTION_HANDLER(method, _, _, startStmt, _, _),
	Stmt(startStmt, method, startIndex).

// The ending statement of a Basic Block is
// the closest ending statement after the starting statement
BB_Range(method, startStmt, endStmt, startIndex, endIndex) :-
	BB_Start(method, startStmt, startIndex),
	BB_End(method, endStmt, endIndex),
	endIndex = min index : { BB_End(method, _, index), index >= startIndex }.

BB_FW_Edge(from, to) :-
	BB_Range(method, from, end, _, endIndex),
	NEXT(end, to),
	BB_Start(method, to, toIndex),
	endIndex < toIndex.

BB_FW_Path(from, to) :-
	BB_FW_Edge(from, to).

BB_FW_Path(from, to) :-
	BB_FW_Path(from, middle),
	BB_FW_Edge(middle, to).

// Simulate forall
// There are two paths to a basic block and
// one is not a sub-path of the other
BB_DOM_Fail(from1, to),
BB_DOM_Fail(from2, to) :-
	BB_FW_Path(from1, to),
	BB_FW_Path(from2, to),
	from1 != from2,
	!BB_FW_Path(from1, from2),
	!BB_FW_Path(from2, from1).

BB_DOM(from, to) :-
	BB_FW_Path(from, to),
	!BB_DOM_Fail(from, to).

// Simulate forall
BB_IDOM_Fail(from, to) :-
	BB_DOM(from, to),
	BB_DOM(from, middle),
	BB_DOM(middle, to).

BB_IDOM(from, to) :-
	BB_DOM(from, to),
	!BB_IDOM_Fail(from, to).

// DF_Local(x) = { y in Succ(x) | x !idom y }
BB_DF_Local(x, y) :-
	BB_Range(_, x, end, _, _),
	NEXT(end, y),
	!BB_IDOM(x, y).

// DF_Upto(x, z) = { y in DF(z) | x idom z && x !idom y }
BB_DF_Upto(x, z, y) :-
	BB_DominanceFrontier(z, y),
	BB_IDOM(x, z),
	x != z,
	x != y,
	!BB_IDOM(x, y).

// DF(x) = DF_Local(x) U ...
BB_DominanceFrontier(x, y) :-
	BB_DF_Local(x, y).

// ... U{z such that x idom z} DF_Upto(x, z)
BB_DominanceFrontier(x, y) :-
	BB_IDOM(x, z),
	BB_DF_Upto(x, z, y).


.decl SSA_PHI(inBB: symbol, var: symbol)
.decl SSA_Assign(stmt: symbol, var: symbol, ssaVar: symbol, index: number, inBB: symbol)
.decl SSA_Operand(stmt: symbol, pos: number, from: symbol)
.decl __VarAliveAtStartOfBB(var: symbol, ssaVar: symbol, inBB: symbol)
.decl __VarAliveAtEndOfBB(var: symbol, ssaVar: symbol, inBB: symbol)
.decl __OperandHasDefInBB(stmt: symbol, var: symbol, ssaVar: symbol)
.decl __StmtInBB(stmt: symbol, inBB: symbol)

// Mock assignments to formal parameters so they are treated uniformly
// in the rest of the SSA logic
SSA_Assign(stmt, var, cat(var, cat("##_", to_string(pos))), 0, stmt) :-
	FORMAL_PARAM(method, pos, var),
	Stmt(stmt, method, 0).

// Rename all "normal" var assigns
SSA_Assign(stmt, var, cat(var, cat("#_", to_string(index))), index, startStmt) :-
	__Assign(stmt, var),
	Stmt(stmt, method, index),
	BB_Range(method, startStmt, _, startIndex, endIndex),
	startIndex <= index, index <= endIndex.

// New var assignment at every Phi
// Add a Phi node only when there are multiple assignments
SSA_PHI(toBB, var),
SSA_Assign(toBB, var, ssaVar, startIndex, toBB) :-
	SSA_Assign(_, var, _, _, fromBB1),
	BB_DominanceFrontier(fromBB1, toBB),
	SSA_Assign(_, var, _, _, fromBB2),
	fromBB1 != fromBB2,
	VarRange(var, varStart, varEnd),
	BB_Start(_, toBB, startIndex),
	varStart <= startIndex, startIndex <= varEnd,
	ssaVar = cat(var, cat("#_", cat(to_string(startIndex), "_PHI"))).

__VarAliveAtStartOfBB(var, ssaVar, toBB) :-
	BB_Range(_, fromBB, endStmt, _, _),
	__VarAliveAtEndOfBB(var, ssaVar, fromBB),
	NEXT(endStmt, toBB),
	BB_Start(_, toBB, toBBIndex),
	VarRange(var, varStart, varEnd),
	varStart <= toBBIndex, toBBIndex <= varEnd.

__VarAliveAtEndOfBB(var, ssaVar, inBB) :-
	SSA_Assign(_, var, ssaVar, maxIndex, inBB),
	maxIndex = max index : SSA_Assign(_, var, _, index, inBB).

__VarAliveAtEndOfBB(var, ssaVar, inBB) :-
	BB_Start(_, inBB, _),
	__VarAliveAtStartOfBB(var, ssaVar, inBB),
	!SSA_Assign(_, var, _, _, inBB).

SSA_Operand(inBB, 0, ssaVar) :-
	SSA_PHI(inBB, var),
	__VarAliveAtStartOfBB(var, ssaVar, inBB).

__StmtInBB(stmt, inBB) :-
	Stmt(stmt, method, index),
	BB_Range(method, inBB, _, startIndex, endIndex),
	startIndex <= index, index <= endIndex.

SSA_Operand(stmt, pos, ssaVar),
__OperandHasDefInBB(stmt, var, ssaVar) :-
	__Operand(stmt, pos, var),
	Stmt(stmt, _, index),
	__StmtInBB(stmt, inBB),
	SSA_Assign(_, var, ssaVar, maxMinIndex, inBB),
	maxMinIndex = max minIndex : { SSA_Assign(_, var, ssaVar, minIndex, inBB), minIndex < index }.

SSA_Operand(stmt, pos, ssaVar) :-
	__Operand(stmt, pos, var),
	__StmtInBB(stmt, inBB),
	!__OperandHasDefInBB(stmt, var, _),
	__VarAliveAtStartOfBB(var, ssaVar, inBB).

// TODO: more like a hack for other cases
SSA_Operand(stmt, pos, var) :-
	__Operand(stmt, pos, var),
	__StmtInBB(stmt, inBB),
	!__OperandHasDefInBB(stmt, var, _),
	!__VarAliveAtStartOfBB(var, _, inBB).