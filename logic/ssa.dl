#pragma once
#include "schema.dl"
#include "basic-blocks.dl"

.decl SSA_PHI(inBB: symbol, var: symbol)
.decl SSA_Assign(stmt: symbol, var: symbol, ssaVar: symbol, index: number, inBB: symbol)
.decl SSA_Operand(stmt: symbol, pos: number, from: symbol)
.decl __VarAliveAtStartOfBB(var: symbol, ssaVar: symbol, inBB: symbol)
.decl __VarAliveAtEndOfBB(var: symbol, ssaVar: symbol, inBB: symbol)
.decl __OperandHasDefInBB(stmt: symbol, var: symbol, ssaVar: symbol)
.decl __StmtInBB(stmt: symbol, inBB: symbol)

// Mock assignments to formal parameters so they are treated uniformly
// in the rest of the SSA logic
// Mock assignments are placed in the fake prologue BB
SSA_Assign(stmt, var, ssaVar, PROLOGUE_INDEX, stmt) :-
	FORMAL_PARAM(method, pos, var),
	BB_Start(method, stmt, PROLOGUE_INDEX),
	ssaVar = cat(var, cat("#_PARAM_", to_string(pos))).

// Rename all "normal" var assigns
SSA_Assign(stmt, var, cat(var, cat("#_", to_string(index))), index, startStmt) :-
	__Assign(stmt, var),
	Stmt(stmt, method, index),
	BB_Range(method, startStmt, _, startIndex, endIndex),
	startIndex <= index, index <= endIndex.

// New var assignment at every Phi
// Add a Phi node only when there are multiple assignments
SSA_PHI(toBB, var),
SSA_Assign(toBB, var, ssaVar, startIndex, toBB) :-
	SSA_Assign(_, var, _, _, fromBB1),
	BB_DominanceFrontier(fromBB1, toBB),
	SSA_Assign(_, var, _, _, fromBB2),
	fromBB1 != fromBB2,
	VarRange(var, varStart, varEnd),
	BB_Start(_, toBB, startIndex),
	varStart <= startIndex, startIndex <= varEnd,
	ssaVar = cat(var, cat("#_PHI_", to_string(startIndex))).

__VarAliveAtStartOfBB(var, ssaVar, toBB) :-
	BB_Range(_, fromBB, endStmt, _, _),
	__VarAliveAtEndOfBB(var, ssaVar, fromBB),
	NEXT(endStmt, toBB),
	BB_Start(_, toBB, toBBIndex),
	VarRange(var, varStart, varEnd),
	varStart <= toBBIndex, toBBIndex <= varEnd.

__VarAliveAtEndOfBB(var, ssaVar, inBB) :-
	SSA_Assign(_, var, ssaVar, maxIndex, inBB),
	maxIndex = max index : SSA_Assign(_, var, _, index, inBB).

__VarAliveAtEndOfBB(var, ssaVar, inBB) :-
	BB_Start(_, inBB, _),
	__VarAliveAtStartOfBB(var, ssaVar, inBB),
	!SSA_Assign(_, var, _, _, inBB).

SSA_Operand(inBB, 0, ssaVar) :-
	SSA_PHI(inBB, var),
	__VarAliveAtStartOfBB(var, ssaVar, inBB).

__StmtInBB(stmt, inBB) :-
	Stmt(stmt, method, index),
	BB_Range(method, inBB, _, startIndex, endIndex),
	startIndex <= index, index <= endIndex.

SSA_Operand(stmt, pos, ssaVar),
__OperandHasDefInBB(stmt, var, ssaVar) :-
	__Operand(stmt, pos, var),
	Stmt(stmt, _, index),
	__StmtInBB(stmt, inBB),
	SSA_Assign(_, var, ssaVar, maxMinIndex, inBB),
	maxMinIndex = max minIndex : { SSA_Assign(_, var, ssaVar, minIndex, inBB), minIndex < index }.

SSA_Operand(stmt, pos, ssaVar) :-
	__Operand(stmt, pos, var),
	__StmtInBB(stmt, inBB),
	!__OperandHasDefInBB(stmt, var, _),
	__VarAliveAtStartOfBB(var, ssaVar, inBB).

// TODO: more like a hack for missing cases
SSA_Operand(stmt, pos, var) :-
	__Operand(stmt, pos, var),
	__StmtInBB(stmt, inBB),
	!__OperandHasDefInBB(stmt, var, _),
	!__VarAliveAtStartOfBB(var, _, inBB).