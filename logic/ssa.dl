#include "facts.dl"

// Starting and ending statements for each Basic Block
.decl BB_Start(method: symbol, stmt: symbol, index: number)
.decl BB_End(method: symbol, stmt: symbol, index: number)
.decl BB_Range(startStmt: symbol, endStmt: symbol)
// Forward paths regarding Basic Blocks
// Each Basic Block is represented by its starting statement
// Paths will be used in dominance, hence BB with back-edges
// certainly do not dominate the head BB
.decl BB_FW_Edge(from: symbol, to: symbol)
.decl BB_FW_Path(from: symbol, to: symbol)
// `from` dominates `to` iff every path from entry to `to` includes `from`
.decl BB_DOM_Fail(from: symbol, to: symbol)
.decl BB_DOM(from: symbol, to: symbol)
// `from` immediate dominates `to` iff `from` dominates `to`
// and there does not exists a node `middle` such that
// `from` dominates `middle` and `middle` dominates `to`
.decl BB_IDOM_Fail(from: symbol, to: symbol)
.decl BB_IDOM(from: symbol, to: symbol)
// Calculate the dominance frontier of each basic block
// Direct computation is quadratic, but a linear algorithm
// uses two intermediate components, DF_Local and DF_Upto
// DF(x) = { y | (exists z in Pred(y) such that x dom z) && x !sdom y }
.decl BB_DF(fromBB: symbol, toBB: symbol)
.decl BB_DF_Local(fromBB: symbol, toBB: symbol)
.decl BB_DF_Upto(fromBB: symbol, middleBB: symbol, toBB: symbol)
.output BB_Range
//.output BB_DOM_Fail
//.output BB_DOM
//.output BB_IDOM_Fail
.output BB_IDOM
.output BB_DF
//.output BB_DF_Local
//.output BB_DF_Upto

// First statement starts a BB
BB_Start(method, stmt, 0) :- Stmt(stmt, method, 0).

// Return statements end a BB
BB_End(method, stmt, index) :-
	(OpcodeExt(stmt, "X-return", _) ;
	 OpcodeExt(stmt, "return", _)),
	Stmt(stmt, method, index).

// A BB ends at a jump,
// and another starts at the target label
BB_End(method, stmt, index),
BB_Start(method, targetStmt, targetIndex) :-
	OpcodeExt(stmt, opcode, targetStmt),
	(ZeroCondJumpOpcode(opcode, _) ;
	 NullCondJumpOpcode(opcode, _) ;
	 CondJumpOpcode(opcode, _) ;
	 opcode = "goto"),
	Stmt(stmt, method, index),
	Stmt(targetStmt, method, targetIndex).

// Whenever a BB ends, another starts
BB_Start(method, startStmt, startIndex) :-
	BB_End(method, endStmt, _),
	NEXT(endStmt, startStmt),
	Stmt(startStmt, method, startIndex).

// Whenever a BB starts, another ends
BB_End(method, endStmt, endIndex) :-
	BB_Start(method, startStmt, _),
	NEXT(endStmt, startStmt),
	Stmt(endStmt, method, endIndex).

// The ending statement of a Basic Block is
// the closest ending statement after the starting statement
BB_Range(startStmt, endStmt) :-
	BB_Start(method, startStmt, startIndex),
	BB_End(method, endStmt, endIndex),
endIndex = min index : { BB_End(method, _, index), index >= startIndex }.

BB_FW_Edge(from, to) :-
	BB_Range(from, endStmt),
	Stmt(endStmt, method, endIndex),
	NEXT(endStmt, to),
	BB_Start(method, to, toIndex),
	endIndex < toIndex.

BB_FW_Path(from, to) :-
	BB_FW_Edge(from, to).

BB_FW_Path(from, to) :-
	BB_FW_Path(from, middle),
	BB_FW_Edge(middle, to).

// Simulate forall
// There are two paths to a basic block and
// one is not a sub-path of the other
BB_DOM_Fail(from1, to),
BB_DOM_Fail(from2, to) :-
	BB_FW_Path(from1, to),
	BB_FW_Path(from2, to),
	from1 != from2,
	!BB_FW_Path(from1, from2),
	!BB_FW_Path(from2, from1).

BB_DOM(from, to) :-
	BB_FW_Path(from, to),
	!BB_DOM_Fail(from, to).

// Simulate forall
BB_IDOM_Fail(from, to) :-
	BB_DOM(from, to),
	BB_DOM(from, middle),
	BB_DOM(middle, to).

BB_IDOM(from, to) :-
	BB_DOM(from, to),
	!BB_IDOM_Fail(from, to).

// DF_Local(x) = { y in Succ(x) | x !idom y }
BB_DF_Local(x, y) :-
	BB_Range(x, endStmt),
	NEXT(endStmt, y),
	!BB_IDOM(x, y).

// DF_Upto(x, z) = { y in DF(z) | x idom z && x !idom y }
BB_DF_Upto(x, z, y) :-
	BB_DF(z, y),
	BB_IDOM(x, z),
	!BB_IDOM(x, y).

// DF(x) = DF_Local(x) U ...
BB_DF(x, y) :-
	BB_DF_Local(x, y).

// ... U{z such that x idom z} DF_Upto(x, z)
BB_DF(x, y) :-
	BB_IDOM(x, z),
	BB_DF_Upto(x, z, y).


.decl DEF_Var_InBB(var: symbol, bb: symbol)
.output DEF_Var_InBB

DEF_Var_InBB(var, startStmt) :-
	ASSIGN(stmt, var),
	Stmt(stmt, method, index),
	BB_Range(startStmt, endStmt),
	Stmt(startStmt, method, startIndex),
	Stmt(endStmt, method, endIndex),
	startIndex <= index, index <= endIndex.

.decl PHI(stmt: symbol, var: symbol)
.output PHI

PHI(toBB, var) :-
	DEF_Var_InBB(var, bb),
	BB_DF(bb, toBB).
