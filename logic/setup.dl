#pragma once
#include "schema.dl"

TypeToDesc("byte", ";B").
TypeToDesc("char", ";C").
TypeToDesc("double", ";D").
TypeToDesc("float", ";F").
TypeToDesc("int", ";I").
TypeToDesc("long", ";J").
TypeToDesc("short", ";S").
TypeToDesc("void", ";V").

ConstLoadOpcode("X-Bconst", desc) :- TypeToDesc("byte", desc).
ConstLoadOpcode("X-Cconst", desc) :- TypeToDesc("char", desc).
ConstLoadOpcode("X-Dconst", desc) :- TypeToDesc("double", desc).
ConstLoadOpcode("X-Fconst", desc) :- TypeToDesc("float", desc).
ConstLoadOpcode("X-Iconst", desc) :- TypeToDesc("int", desc).
ConstLoadOpcode("X-Jconst", desc) :- TypeToDesc("long", desc).
ConstLoadOpcode("X-Sconst", desc) :- TypeToDesc("short", desc).
ConstLoadOpcode("X-Lconst", ";L"). // string literals

BinOpcode("X-add", "+").
BinOpcode("X-sub", "-").
BinOpcode("X-mul", "*").
BinOpcode("X-div", "/").
BinOpcode("X-rem", "%").
BinOpcode("X-band", "&").
BinOpcode("X-bor", "|").
BinOpcode("X-bxor", "^").
BinOpcode("X-shl", "<<").
BinOpcode("X-shr", ">>").
BinOpcode("X-ushr", ">>>").
BinOpcode("lcmp", "cmp").
BinOpcode("cmpl", "cmp").
BinOpcode("cmpg", "cmp").
UnaryOpcode("X-neg", "-").

CallOpcode("invokevirtual").
CallOpcode("invokespecial").
CallOpcode("X-invokeinit").
CallOpcode("invokestatic").

ImplicitCondJumpOpcode("ifeq", "==", "I", "0").
ImplicitCondJumpOpcode("ifne", "!=", "I", "0").
ImplicitCondJumpOpcode("iflt", "<", "I", "0").
ImplicitCondJumpOpcode("ifge", ">=", "I", "0").
ImplicitCondJumpOpcode("ifgt", ">", "I", "0").
ImplicitCondJumpOpcode("ifle", "<=", "I", "0").
ImplicitCondJumpOpcode("ifnull", "==", "n", "NULL").
ImplicitCondJumpOpcode("ifnonnull", "!=", "n", "NULL").

CondJumpOpcode("if_icmpeq", "==").
CondJumpOpcode("if_icmpne", "!=").
CondJumpOpcode("if_icmplt", "<").
CondJumpOpcode("if_icmpge", ">=").
CondJumpOpcode("if_icmpgt", ">").
CondJumpOpcode("if_icmple", "<=").
CondJumpOpcode("if_acmpeq", "==").
CondJumpOpcode("if_acmpne", "!=").


// The endIndex in VarRange is not inclusive in the original bytecode
VAR(method, var, type, name),
VarRange(var, startIndex, endIndex - 1) :-
	__Var(method, _, var, name, type, startLabel, endLabel),
	Label(method, startLabel, _, startIndex),
	Label(method, endLabel, _, endIndex).

// Formal params are alive from the beginning of the method
// Assume slot order (i.e., index) reflects parameter order
FORMAL_PARAM(method, to_number(pos), var) :-
	__Var(method, pos, var, _, _, startLabel, _),
	Label(method, startLabel, _, 0).

// Match load/store statements to variable scopes
// The first store statement of a variable is one index
// before the variable's scope start
OpcodeExt(stmt, opcode, var) :-
	((__Opcode(stmt, "X-load", varIndex), opcode = "X-load") ;
	 (__Opcode(stmt, "X-store", varIndex), opcode = "X-store") ;
	 (__Opcode(stmt, "X-inc", varIndex), opcode = "X-inc") ;
	 (__Opcode(stmt, "X-dec", varIndex), opcode = "X-dec")),
	BytecodeStmt(stmt, method, index),
	__Var(method, varIndex, var, _, _, _, _),
	VarRange(var, startIndex, endIndex),
	(startIndex - 1) <= index, index <= endIndex.

// Exception handlers might introduce unnamed variables
OpcodeExt(stmt, opcode, var) :-
	((__Opcode(stmt, "X-load", varIndex), opcode = "X-load") ;
	 (__Opcode(stmt, "X-store", varIndex), opcode = "X-store")),
	BytecodeStmt(stmt, method, _),
	!__Var(method, varIndex, _, _, _, _, _),
	var = cat(cat(method, "/"), cat("$throw", varIndex)).

// Anything other than var load/store and jumps
OpcodeExt(stmt, opcode, oper) :-
	__Opcode(stmt, opcode, oper),
	opcode != "X-load",
	opcode != "X-store",
	opcode != "X-inc",
	opcode != "X-dec",
	opcode != "goto",
	!ImplicitCondJumpOpcode(opcode, _, _, _),
	!CondJumpOpcode(opcode, _).

NEXT(stmt, nextStmt),
OpcodeExt(stmt, opcode, nextStmt) :-
	__Opcode(stmt, opcode, label),
	(ImplicitCondJumpOpcode(opcode, _, _, _) ;
	 CondJumpOpcode(opcode, _)),
	BytecodeStmt(stmt, method, _),
	Label(method, label, nextStmt, _).

NEXT(stmt, nextStmt),
OpcodeExt(stmt, "goto", nextStmt) :-
	__Opcode(stmt, "goto", label),
	BytecodeStmt(stmt, method, _),
	Label(method, label, nextStmt, _).

// The next statement, in sequence, is also a successor in most cases
NEXT(stmt, cat(method, cat("/", to_string(i+1)))) :-
	__Opcode(stmt, opcode, _),
	BytecodeStmt(stmt, method, i),
	opcode != "goto",
	opcode != "athrow",
	opcode != "X-return",
	opcode != "return".

// Assume that the first instruction of a handler is a store
EXCEPTION_HANDLER(method, startStmt, endStmt, handlerStmt, type, var) :-
	Handler(method, startLabel, endLabel, handlerLabel, type),
	Label(method, startLabel, startStmt, _),
	Label(method, endLabel, endStmt, _),
	Label(method, handlerLabel, handlerStmt, _),
	OpcodeExt(handlerStmt, "X-store", var).

///////////////////////////////////////////////////////////////

.decl __StackForSymbol(stack: Stack)
__StackForSymbol(stack) :- StackBeforeStmt(_, stack).
__StackForSymbol(stack) :- __StackForSymbol([_, stack]).

.decl __ToSymbol(stack: Stack, out: symbol)
__ToSymbol(nil, "=@@=") :- __StackForSymbol(nil).
__ToSymbol([head, stack], cat(head, cat(", ", out0))) :-
	__StackForSymbol([head, stack]), __ToSymbol(stack, out0).

DEBUG(stmt, out) :- StackBeforeStmt(stmt, stack), __ToSymbol(stack, out).